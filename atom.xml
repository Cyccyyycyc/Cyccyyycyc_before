<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cy</title>
  
  
  <link href="https://cyccyyycyc.github.io/atom.xml" rel="self"/>
  
  <link href="https://cyccyyycyc.github.io/"/>
  <updated>2022-10-23T04:36:33.971Z</updated>
  <id>https://cyccyyycyc.github.io/</id>
  
  <author>
    <name>Cy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hierarchical-Clustering</title>
    <link href="https://cyccyyycyc.github.io/2022/10/22/Hierarchical-Clustering/"/>
    <id>https://cyccyyycyc.github.io/2022/10/22/Hierarchical-Clustering/</id>
    <published>2022-10-22T11:10:17.000Z</published>
    <updated>2022-10-23T04:36:33.971Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="层次聚类-Hierarchical-Clustering"><a href="#层次聚类-Hierarchical-Clustering" class="headerlink" title="层次聚类 Hierarchical-Clustering"></a>层次聚类 Hierarchical-Clustering</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>随着网络技术的发展，我们迎来了信息爆炸的时代。我们都知道现代大数据有4个特点：</p><ol><li>体量大 Volume</li><li>高速化 Velocity</li><li>多样化 Variety</li><li>低价值密度 Value</li></ol><p>未经处理的数据信息之间的联系往往较低，体量大而价值密度低。为了更好地挖掘数据价值，一个思路是找到数据之间的相似点进行度量和聚类，将数据点进行聚类，获得关联以更好地利用数据。网络世界中的推荐算法就是数据应用的一个典型例子。如淘宝、京东、拼多多等购物平台的商品推荐页面，谷歌、百度等搜索引擎的推荐回答，网易云音乐的日推歌曲……高效的推荐算法可以帮助我们快速的从体量庞大的信息流中定位到我们需要的有价值的数据，一定程度上便利了我们的生活。</p><p>推荐算法如何能实现推荐我们感兴趣的内容呢？我们往往会发现这样一个事实：品味相似的人会对相似的事物感兴趣。由此衍生出的一个思路是从相似的人出发：如找到兴趣爱好相同的两个人A和B，便可以将A感兴趣的内容推荐给B，由此推广到整个社区类群。在实际应用中，有协同过滤算法基于用户历史数据对用户进行群组划分并在此基础上推荐相似的物品，挖掘用户潜在兴趣。</p><p>在协同过滤中实现聚类有较多方法，本实验选择自底向上的层次聚类进行复现。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>先明确我们要实现什么：我们有一些离散的无关联的数据点，想要衡量它们之间的相似度，并以此为准则进行聚类。</p><p>那么这就要解决2个问题：</p><ol><li>相似度如何定义？</li><li>如何评估聚类的效果？</li></ol><p>首先，关于相似度定义的问题，需要定义一个函数来进行样本距离的衡量。如：</p><ol><li>Single-Linkage最短距离法：取两个类中距离最近的两个样本的距离作为两个集合的距离。</li><li>Complete-Linkage最长距离法：取两个集合中距离最远的两个点的距离作为两个集合的距离。</li><li>Average-linkage中间距离法：取两两距离的平均值作为两个集合之间的距离。</li><li>类平均法：取两两距离的中值作为两个集合之间的距离。</li></ol><p>四种方法各有特点：</p><ol><li>最短距离法相对限制较少，最终会得到一个相对松散的社群。</li><li>最长距离法相对限制较大。一个问题是：有可能两个类群已经很接近了，但由于单个样本的干扰便没有合并。</li><li>最短距离和最长距离法这考虑了某个有特点的数据，而没有考虑类内数据的整体特点，时间复杂度相对较低。</li><li>类平均法与取均值相比更能消除个别偏离样本对结果的干扰。</li></ol><p>其次，关于聚类效果评估的问题。容易发现，聚类和分类是不同的。对于分类问题，我们已经有了正确的标签，因此分类问题是一个有监督的学习。而聚类本身没有一个“正确”的结果，是一种无监督的学习。因为聚类没有一个确定的答案，目前尚未有一个效果较好的的评测指标评价聚类效果，更多的是靠数据可视化和人工评测效果。</p><p>层次聚类有两种思路：</p><ol><li>自底向上的凝聚法：凝聚法指的是初始时将每个样本点当做一个类簇，然后依据相似度合并这些初始的类簇，直到达到某种条件或者达到设定的分类数目。</li><li>自顶向下的分裂法：初始时将所有的样本归为一个类簇，然后依据相似度进行逐渐的分裂，直到达到某种条件或者达到设定的分类数目。</li></ol><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>距离度量函数可以任意定义，较为灵活。</li><li>层次聚类结果是一个树状图，包含关系结构清晰，一个结点可以属于多个类。</li><li>一次性获得整个聚类树，可以直接根据需要对聚类树进行横向切割获得指定数量的类簇。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>计算复杂度大</li><li>贪心算法获得局部最优，不一定是全局最优解。</li><li>层次聚类具有不可逆性，一旦聚类结果形成，想要就不能重新合并来优化聚类性能。</li><li>对于不同的问题，需要人为选择合适的距离度量函数、终止条件和参数。</li></ol><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li>移除网络中的所有边，得到有 n 个孤立节点，每个节点作为一个集合。</li><li>两两计算相似度</li><li>根据选取相似度最小的两个结点进行合并</li><li>重复2和3直到满足条件终止，形成树状图</li><li>根据实际需求横切树状图，获得聚类的社区结构</li></ol><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python==3.8.8</span><br><span class="line">numpy==1.23.3</span><br><span class="line">scipy==1.7.0</span><br><span class="line">scikit-learn==1.1.2</span><br><span class="line">matplotlib==3.5.3</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.cluster <span class="keyword">import</span> hierarchy</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> AgglomerativeClustering</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入数据集</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">iris_data = iris.data</span><br><span class="line"><span class="built_in">print</span>(iris_data.shape, iris_data.dtype)</span><br><span class="line"><span class="comment"># output:(150, 4) float64</span></span><br></pre></td></tr></table></figure><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据集预处理</span></span><br><span class="line"></span><br><span class="line">data = np.array(iris_data[:, <span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(data.shape)</span><br><span class="line"><span class="comment"># output:(150, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据的每一个特征缩放到给定的范围(0,1)</span></span><br><span class="line">min_max_scaler = preprocessing.MinMaxScaler()</span><br><span class="line">data_M = min_max_scaler.fit_transform(data)</span><br></pre></td></tr></table></figure><h4 id="层次聚类树状图"><a href="#层次聚类树状图" class="headerlink" title="层次聚类树状图"></a>层次聚类树状图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">6</span>))</span><br><span class="line">plt.title(<span class="string">&quot;Dendrograms&quot;</span>)  </span><br><span class="line"><span class="comment">#  ward：集合间距离等于两类对象之间的最小距离。（即最短距离法single-linkage聚类）</span></span><br><span class="line"><span class="comment">#  计算距离的方法，可以是 “euclidean”（即 “l2”，欧氏距离）</span></span><br><span class="line">Z = hierarchy.linkage(data_scaled, method=<span class="string">&#x27;ward&#x27;</span>, metric=<span class="string">&#x27;euclidean&#x27;</span>)</span><br><span class="line">p = hierarchy.dendrogram(Z, <span class="number">0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2022/10/22/Hierarchical-Clustering/1.jpg" alt="1"></p><h4 id="层次聚类分布图"><a href="#层次聚类分布图" class="headerlink" title="层次聚类分布图"></a>层次聚类分布图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  ward：集合间距离等于两类对象之间的最小距离。（即最短距离法single-linkage聚类）</span></span><br><span class="line"><span class="comment">#  计算距离的方法，可以是 “euclidean”（即 “l2”，欧氏距离）</span></span><br><span class="line">ac = AgglomerativeClustering(n_clusters=<span class="number">6</span>, affinity=<span class="string">&#x27;euclidean&#x27;</span>, linkage=<span class="string">&#x27;ward&#x27;</span>)</span><br><span class="line">ac.fit(data_scaled)</span><br><span class="line">labels = ac.fit_predict(data_scaled)</span><br><span class="line">plt.scatter(data_scaled[:,<span class="number">0</span>], data_scaled[:,<span class="number">1</span>], c=labels)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2022/10/22/Hierarchical-Clustering/2.jpg" alt="2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;层次聚类-Hierarchical-Clustering&quot;&gt;&lt;a href=&quot;#层次聚类-Hierarchical-Clustering&quot; class=&quot;headerlink&quot; title=&quot;层次聚类 Hierarchical-Clust</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>move-zeros</title>
    <link href="https://cyccyyycyc.github.io/2022/10/22/move-zeros/"/>
    <id>https://cyccyyycyc.github.io/2022/10/22/move-zeros/</id>
    <published>2022-10-22T06:03:13.000Z</published>
    <updated>2022-10-22T06:06:47.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="move-zeros"><a href="#move-zeros" class="headerlink" title="move-zeros"></a><a href="https://leetcode.cn/problems/move-zeroes/">move-zeros</a></h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow = fast = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num != <span class="number">0</span>:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 尾部置零</span></span><br><span class="line">        <span class="keyword">while</span>(slow &lt; fast):</span><br><span class="line">            nums[slow] = <span class="number">0</span></span><br><span class="line">            slow += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="move-amp-append"><a href="#move-amp-append" class="headerlink" title="move &amp; append"></a>move &amp; append</h2><p>这个相对来说慢很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> <span class="keyword">in</span> nums:</span><br><span class="line">            nums.remove(<span class="number">0</span>)</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (cnt):</span><br><span class="line">            nums.append(<span class="number">0</span>)</span><br><span class="line">            cnt -= <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;move-zeros&quot;&gt;&lt;a href=&quot;#move-zeros&quot; class=&quot;headerlink&quot; title=&quot;move-zeros&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/move-zeroes/&quot;&gt;move</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>roman-to-integer</title>
    <link href="https://cyccyyycyc.github.io/2022/10/22/roman-to-integer/"/>
    <id>https://cyccyyycyc.github.io/2022/10/22/roman-to-integer/</id>
    <published>2022-10-22T03:26:12.000Z</published>
    <updated>2022-10-22T03:31:43.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="roman-to-integer"><a href="#roman-to-integer" class="headerlink" title="roman-to-integer"></a><a href="https://leetcode.cn/problems/roman-to-integer/">roman-to-integer</a></h1><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="built_in">dict</span> = &#123;<span class="string">&#x27;I&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;V&#x27;</span>:<span class="number">5</span>, <span class="string">&#x27;X&#x27;</span>:<span class="number">10</span>, <span class="string">&#x27;L&#x27;</span>:<span class="number">50</span>, <span class="string">&#x27;C&#x27;</span>:<span class="number">100</span>, <span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>, <span class="string">&#x27;M&#x27;</span>:<span class="number">1000</span>&#125;</span><br><span class="line">        st = [<span class="number">0</span>]</span><br><span class="line">        top = ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            st.append(<span class="built_in">dict</span>[i])</span><br><span class="line">            <span class="comment"># 小数在大数前面，则小数取负</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dict</span>[i]&gt;st[top]):</span><br><span class="line">                st[top] = - st[top]</span><br><span class="line">            top += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> st:</span><br><span class="line">            ans += i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;roman-to-integer&quot;&gt;&lt;a href=&quot;#roman-to-integer&quot; class=&quot;headerlink&quot; title=&quot;roman-to-integer&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>longest-common-prefix</title>
    <link href="https://cyccyyycyc.github.io/2022/10/22/longest-common-prefix/"/>
    <id>https://cyccyyycyc.github.io/2022/10/22/longest-common-prefix/</id>
    <published>2022-10-22T02:45:49.000Z</published>
    <updated>2022-10-22T02:53:44.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="longest-common-prefix"><a href="#longest-common-prefix" class="headerlink" title="longest-common-prefix"></a><a href="https://leetcode.cn/problems/longest-common-prefix/">longest-common-prefix</a></h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>逐次遍历，两两找最长前缀。</p><p>注意每次拿前缀和新的字符串比较时，用切片保证前缀长度比新字符串小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        prefix = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> prefix</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prefix = strs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> str0 <span class="keyword">in</span> strs:</span><br><span class="line">            <span class="comment"># 前缀长度一定是最小的</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(str0) &lt; <span class="built_in">len</span>(prefix):</span><br><span class="line">                prefix = prefix[<span class="number">0</span>: <span class="built_in">len</span>(str0)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(<span class="built_in">len</span>(str0), <span class="built_in">len</span>(prefix))):</span><br><span class="line">                <span class="keyword">if</span> prefix[i]!= str0[i]:</span><br><span class="line">                    prefix = prefix[<span class="number">0</span>:i]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> prefix</span><br></pre></td></tr></table></figure><h2 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h2><p>用min和max获得字典排序的最小串和最大串，直接找两者最大前缀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        str0, str1 = <span class="built_in">min</span>(strs), <span class="built_in">max</span>(strs)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str0)):</span><br><span class="line">            <span class="keyword">if</span> str0[i]!=str1[i]:</span><br><span class="line">                <span class="keyword">return</span> str0[:i]</span><br><span class="line">        <span class="keyword">return</span> str0</span><br></pre></td></tr></table></figure><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>set函数生成集合，集合中不能有相同元素，可以用集合长度确定strs相同位置的元素是否相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        prefix = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(*strs)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(i))==<span class="number">1</span>:</span><br><span class="line">                prefix += i[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> prefix</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;longest-common-prefix&quot;&gt;&lt;a href=&quot;#longest-common-prefix&quot; class=&quot;headerlink&quot; title=&quot;longest-common-prefix&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetco</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>merge-two-sorted-lists</title>
    <link href="https://cyccyyycyc.github.io/2022/10/21/merge-two-sorted-lists/"/>
    <id>https://cyccyyycyc.github.io/2022/10/21/merge-two-sorted-lists/</id>
    <published>2022-10-21T06:42:21.000Z</published>
    <updated>2022-10-21T06:47:46.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="merge-two-sorted-lists"><a href="#merge-two-sorted-lists" class="headerlink" title="merge-two-sorted-lists"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">merge-two-sorted-lists</a></h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &gt; list2.val:</span><br><span class="line">                list1, list2 = list2, list1</span><br><span class="line">            list1.<span class="built_in">next</span> = self.mergeTwoLists(list1.<span class="built_in">next</span>, list2)</span><br><span class="line">        <span class="keyword">return</span> list1 <span class="keyword">or</span> list2</span><br></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>用带头节点的单链表统一操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        tmp = cur = ListNode(-<span class="number">1</span>)  <span class="comment"># Head Node</span></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &gt; list2.val:</span><br><span class="line">                cur.<span class="built_in">next</span>, list2 = list2, list2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span>, list1 = list1, list1.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">        <span class="keyword">return</span> tmp.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;merge-two-sorted-lists&quot;&gt;&lt;a href=&quot;#merge-two-sorted-lists&quot; class=&quot;headerlink&quot; title=&quot;merge-two-sorted-lists&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://lee</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>search-insert-position</title>
    <link href="https://cyccyyycyc.github.io/2022/10/21/search-insert-position/"/>
    <id>https://cyccyyycyc.github.io/2022/10/21/search-insert-position/</id>
    <published>2022-10-21T06:11:51.000Z</published>
    <updated>2022-10-21T06:17:15.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="search-insert-position"><a href="#search-insert-position" class="headerlink" title="search-insert-position"></a><a href="https://leetcode.cn/problems/search-insert-position">search-insert-position</a></h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>时间复杂度O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span>(target &lt;= n):</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>时间复杂度为 O(log n) </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r):</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target):</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (nums[mid]&lt;target):</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;search-insert-position&quot;&gt;&lt;a href=&quot;#search-insert-position&quot; class=&quot;headerlink&quot; title=&quot;search-insert-position&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://lee</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>remove-element</title>
    <link href="https://cyccyyycyc.github.io/2022/10/20/remove-element/"/>
    <id>https://cyccyyycyc.github.io/2022/10/20/remove-element/</id>
    <published>2022-10-20T12:14:18.000Z</published>
    <updated>2022-10-21T03:50:13.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="remove-element"><a href="#remove-element" class="headerlink" title="remove-element"></a><a href="https://leetcode.cn/problems/remove-element/">remove-element</a></h1><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><h2 id="反向遍历POP"><a href="#反向遍历POP" class="headerlink" title="反向遍历POP"></a>反向遍历POP</h2><p>注意索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val):</span><br><span class="line">                nums.pop(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>记录val值个数，一次循环，元素前移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            nums[i-k] = nums[i]</span><br><span class="line">            <span class="keyword">if</span>(n==val):</span><br><span class="line">                k = k+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l-k</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>l为新数组索引，r为原数组索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span>(nums[r]!=val):</span><br><span class="line">                nums[l]=nums[r]</span><br><span class="line">                l = l+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure><h2 id="count-amp-remove"><a href="#count-amp-remove" class="headerlink" title="count &amp; remove"></a>count &amp; remove</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a = nums.count(val)  <span class="comment"># 计算数组nums中val值的个数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a):</span><br><span class="line">            nums.remove(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><h2 id="index-amp-del"><a href="#index-amp-del" class="headerlink" title="index &amp; del"></a>index &amp; del</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">while</span> val <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">del</span> nums[nums.index(val)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;remove-element&quot;&gt;&lt;a href=&quot;#remove-element&quot; class=&quot;headerlink&quot; title=&quot;remove-element&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>remove-duplicates-from-sorted-array</title>
    <link href="https://cyccyyycyc.github.io/2022/10/20/remove-duplicates-from-sorted-array/"/>
    <id>https://cyccyyycyc.github.io/2022/10/20/remove-duplicates-from-sorted-array/</id>
    <published>2022-10-20T12:10:30.000Z</published>
    <updated>2022-10-21T03:50:06.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="remove-duplicates-from-sorted-array"><a href="#remove-duplicates-from-sorted-array" class="headerlink" title="remove-duplicates-from-sorted-array"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array">remove-duplicates-from-sorted-array</a></h1><p>删除有序数组中的重复项</p><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><h2 id="1-倒序POP"><a href="#1-倒序POP" class="headerlink" title="1 倒序POP"></a>1 倒序POP</h2><p>注意索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i-<span class="number">1</span>]):</span><br><span class="line">                nums.pop(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><h2 id="2-快慢指针"><a href="#2-快慢指针" class="headerlink" title="2 快慢指针"></a>2 快慢指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        fast = <span class="number">1</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[slow]):</span><br><span class="line">                slow = slow + <span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">            fast = fast + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;remove-duplicates-from-sorted-array&quot;&gt;&lt;a href=&quot;#remove-duplicates-from-sorted-array&quot; class=&quot;headerlink&quot; title=&quot;remove-duplicates-from</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>palindrome-number</title>
    <link href="https://cyccyyycyc.github.io/2022/10/20/palindrome-number/"/>
    <id>https://cyccyyycyc.github.io/2022/10/20/palindrome-number/</id>
    <published>2022-10-20T12:00:38.000Z</published>
    <updated>2022-10-21T03:49:58.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="palindrome-number"><a href="#palindrome-number" class="headerlink" title="palindrome-number"></a><a href="https://leetcode.cn/problems/palindrome-number/">palindrome-number</a></h1><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>例如，121 是回文，而 123 不是。</p><h2 id="直接计算"><a href="#直接计算" class="headerlink" title="直接计算"></a>直接计算</h2><p>如果x小于0则必不是回文数<br>如果x大于0则计算其倒序数值，比较和原x是否相等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> x&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = <span class="number">0</span></span><br><span class="line">            num = x</span><br><span class="line">            <span class="keyword">while</span>(num&gt;<span class="number">0</span>):</span><br><span class="line">                cur = cur*<span class="number">10</span> + num%<span class="number">10</span></span><br><span class="line">                num = num//<span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> cur == x      </span><br></pre></td></tr></table></figure><h2 id="反向切片"><a href="#反向切片" class="headerlink" title="反向切片"></a>反向切片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(x) == <span class="built_in">str</span>(x)[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;palindrome-number&quot;&gt;&lt;a href=&quot;#palindrome-number&quot; class=&quot;headerlink&quot; title=&quot;palindrome-number&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/proble</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>valid-parentheses</title>
    <link href="https://cyccyyycyc.github.io/2022/10/20/valid-parentheses/"/>
    <id>https://cyccyyycyc.github.io/2022/10/20/valid-parentheses/</id>
    <published>2022-10-20T11:55:38.000Z</published>
    <updated>2022-10-21T03:50:41.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="valid-parentheses"><a href="#valid-parentheses" class="headerlink" title="valid-parentheses"></a><a href="https://leetcode.cn/problems/valid-parentheses/description/">valid-parentheses</a></h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>利用字典构造匹配关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="built_in">dict</span> = &#123;<span class="string">&#x27;(&#x27;</span>:<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>:<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;[&#x27;</span>:<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;?&#x27;</span>:<span class="string">&#x27;?&#x27;</span>&#125;</span><br><span class="line">        stack = [<span class="string">&#x27;?&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="built_in">dict</span>:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">dict</span>[stack.pop()] != c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack)==<span class="number">1</span></span><br><span class="line">                       </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;valid-parentheses&quot;&gt;&lt;a href=&quot;#valid-parentheses&quot; class=&quot;headerlink&quot; title=&quot;valid-parentheses&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/proble</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>reverse-linked-list</title>
    <link href="https://cyccyyycyc.github.io/2022/10/20/reverse-linked-list/"/>
    <id>https://cyccyyycyc.github.io/2022/10/20/reverse-linked-list/</id>
    <published>2022-10-20T11:26:17.000Z</published>
    <updated>2022-10-21T03:50:19.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="reverse-linked-list"><a href="#reverse-linked-list" class="headerlink" title="reverse-linked-list"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">reverse-linked-list</a></h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        ans = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            p = head.<span class="built_in">next</span></span><br><span class="line">            head.<span class="built_in">next</span> = ans</span><br><span class="line">            ans = head</span><br><span class="line">            head = p</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        last = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;reverse-linked-list&quot;&gt;&lt;a href=&quot;#reverse-linked-list&quot; class=&quot;headerlink&quot; title=&quot;reverse-linked-list&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>two-sum</title>
    <link href="https://cyccyyycyc.github.io/2022/10/20/two-sum/"/>
    <id>https://cyccyyycyc.github.io/2022/10/20/two-sum/</id>
    <published>2022-10-20T11:02:12.000Z</published>
    <updated>2022-10-21T03:50:34.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="two-sum"><a href="#two-sum" class="headerlink" title="two-sum"></a><a href="https://leetcode.cn/problems/two-sum/">two-sum</a></h1><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>例如：</p><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>空间复杂度O(n)<br>时间复杂度O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            x = target - n</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> <span class="built_in">dict</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="built_in">dict</span>[x], i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">dict</span>[n] = i</span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>两层循环，时间复杂度O(n^2)<br>注意：不能考虑重复元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, l, <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;two-sum&quot;&gt;&lt;a href=&quot;#two-sum&quot; class=&quot;headerlink&quot; title=&quot;two-sum&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/two-sum/&quot;&gt;two-sum&lt;/a&gt;&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>The Transfer-based Black-box Attack Method by 韦星星</title>
    <link href="https://cyccyyycyc.github.io/2022/10/19/The-Transfer-based-Black-box-Attack-Method-by%E9%9F%A6%E6%98%9F%E6%98%9F/"/>
    <id>https://cyccyyycyc.github.io/2022/10/19/The-Transfer-based-Black-box-Attack-Method-by%E9%9F%A6%E6%98%9F%E6%98%9F/</id>
    <published>2022-10-19T15:57:49.000Z</published>
    <updated>2022-10-21T03:50:27.089Z</updated>
    
    <content type="html"><![CDATA[<p>观后感</p><p><a href="http://scl.sribd.cn/seminar/index.html">Source</a> The 4th Lecture</p><h2 id="基于Spatial-Momentum的迁移性增强方法"><a href="#基于Spatial-Momentum的迁移性增强方法" class="headerlink" title="基于Spatial Momentum的迁移性增强方法"></a>基于Spatial Momentum的迁移性增强方法</h2><h3 id="FGSM-Fast-Gradient-Sign-Method"><a href="#FGSM-Fast-Gradient-Sign-Method" class="headerlink" title="FGSM : Fast Gradient Sign Method"></a>FGSM : Fast Gradient Sign Method</h3><p>白盒场景下，用符号获得梯度方向，在原图增加噪声（对抗扰动）来生成对抗样本，是一种单步迭代攻击。</p><h3 id="I-FGSM-Iterative-Fast-Gradient-Sign-Method"><a href="#I-FGSM-Iterative-Fast-Gradient-Sign-Method" class="headerlink" title="I-FGSM : Iterative Fast Gradient Sign Method"></a>I-FGSM : Iterative Fast Gradient Sign Method</h3><p>多步迭代攻击，拟合效果更好了，但是迁移性不太好（可以从overfit角度直观理解）</p><h4 id="时序累加角度：时间域变换"><a href="#时序累加角度：时间域变换" class="headerlink" title="时序累加角度：时间域变换"></a>时序累加角度：时间域变换</h4><h5 id="MI-FGSM"><a href="#MI-FGSM" class="headerlink" title="MI-FGSM"></a>MI-FGSM</h5><p>时序上的梯度累加：当前梯度+过去梯度</p><h5 id="NI-FGSM"><a href="#NI-FGSM" class="headerlink" title="NI-FGSM"></a>NI-FGSM</h5><h4 id="数据增广角度：空间域变换"><a href="#数据增广角度：空间域变换" class="headerlink" title="数据增广角度：空间域变换"></a>数据增广角度：空间域变换</h4><h5 id="DII-FGSM-Diverse-Inputs"><a href="#DII-FGSM-Diverse-Inputs" class="headerlink" title="DII-FGSM : Diverse Inputs"></a>DII-FGSM : Diverse Inputs</h5><p>从数据增强角度，对输入数据有概率p进行随机大小的resize</p><h5 id="TI-FGSM-Translation-invariant-FGSM"><a href="#TI-FGSM-Translation-invariant-FGSM" class="headerlink" title="TI-FGSM : Translation invariant - FGSM"></a>TI-FGSM : Translation invariant - FGSM</h5><p>从数据增强角度，考虑像素点的领域（高斯）来生成对抗样本。</p><h4 id="时空累加角度"><a href="#时空累加角度" class="headerlink" title="时空累加角度"></a>时空累加角度</h4><h5 id="R-DIMI-FGSM"><a href="#R-DIMI-FGSM" class="headerlink" title="R-DIMI-FGSM"></a>R-DIMI-FGSM</h5><p>考虑梯度在空间上的累加，比较范围更广</p><h2 id="图像检测对抗样本的生成"><a href="#图像检测对抗样本的生成" class="headerlink" title="图像检测对抗样本的生成"></a>图像检测对抗样本的生成</h2><h3 id="现有方法问题"><a href="#现有方法问题" class="headerlink" title="现有方法问题"></a>现有方法问题</h3><p>现有攻击方法常常针对Fast-rcnn，攻击模型中的的分类模块（常常表征高级特征），而有些图像检测模型如yolo模型中无分类模块，则导致迁移性差。</p><ol><li>迁移性差，在一个模型训练生成的对抗样本往往无法成功攻击另一个模型。</li><li>时间复杂度高</li></ol><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><h4 id="改进描述"><a href="#改进描述" class="headerlink" title="改进描述"></a>改进描述</h4><p>一种想法是对抗样本迁移和模型之间的共性相关。要想增强迁移能力，则应该从模型间的共性切入。</p><p>传统方法是攻击Fast-rcnn模型中的分类模块，而有些模型中不存在分类模块，则分类模块显然不是模型的共同子架构。</p><p>因此，提出基于base network的对抗样本生成，取Fast-rcnn模型中一些普遍应用的架构（如VGG、ResNet一些经典架构…），用attention机制来定位特征层的目标机制，增加feature loss，从中间特征层入手破坏物体特征层的特征（原来是直接攻击模型更后面更高级的分类模块），获得更高的迁移性。</p><h4 id="Q1-：底层特征更共性？"><a href="#Q1-：底层特征更共性？" class="headerlink" title="Q1 ：底层特征更共性？"></a>Q1 ：底层特征更共性？</h4><p>这时候可能有人会提出一个问题，既然攻击迁移性往往和模型之间的共同点高度相关，那为什么不选取破坏更加具有共性的底层特征来获得更大的迁移性呢？回答是这样对图片的破坏较大，会导致对抗样本和原图的距离较远，选择在中间特征层攻击是对图片质量（和原图的相似度）和迁移性的权衡结果。</p><p>进一步解释，神经网络往往是一个放大的过程，在底层添加微小噪声，经过网络不断放大，最终和原图便相去甚远。</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="Q1：可以从什么角度切入提高迁移性"><a href="#Q1：可以从什么角度切入提高迁移性" class="headerlink" title="Q1：可以从什么角度切入提高迁移性?"></a>Q1：可以从什么角度切入提高迁移性?</h3><ol><li>从梯度出发，找到一个更泛化的梯度计算的方法</li><li>从模型架构共性出发。现在的模型架构趋于模块化，更容易找到共性，提高迁移性。</li><li>（笔者目前个人认为）从模型拟合数据分布的角度出发。不同模型学到的知识不同，有的模型注重纹理有的注重轮廓。</li></ol><h3 id="Q2-：无法被迁移攻击的模型？"><a href="#Q2-：无法被迁移攻击的模型？" class="headerlink" title="Q2 ：无法被迁移攻击的模型？"></a>Q2 ：无法被迁移攻击的模型？</h3><ol><li>从模型架构共性出发：黑盒场景下，如果一个模型无法被迁移攻击，那么说明本地模型和目标模型相似度极低。这不太符合现实应用。不过脉冲神经网络或许是一个角度。</li><li>从模型拟合数据分布角度出发：往往经过对抗训练的模型会具有更高的鲁棒性，相同架构下往往会更难以被对抗攻击，这表明模型拟合出了一个不一样的分布，这个分布含有更多的知识。（有点像“吃一堑长一智”，模型之前见识过了对抗攻击，便学会了如何应对）</li></ol><h3 id="Q3-：语义角度的迁移攻击？"><a href="#Q3-：语义角度的迁移攻击？" class="headerlink" title="Q3 ：语义角度的迁移攻击？"></a>Q3 ：语义角度的迁移攻击？</h3><p>现有方法往往修改图像亮度、锐度、饱和度等属性（对抗属性）来生成对抗样本。可以进行扩展，尝试修改一些视觉友好的语义属性（比如颜色）来生成对抗样本，思考并探索：哪种属性更易于迁移？</p><h3 id="Q4-：如何寻找共性？"><a href="#Q4-：如何寻找共性？" class="headerlink" title="Q4 ：如何寻找共性？"></a>Q4 ：如何寻找共性？</h3><ol><li>从data的特征空间变换角度，可以寻找不同模型之间的一致性</li><li>从降维解构角度，可以实现降低搜索维度，在低维空间中搜索降低时间复杂度，在高维空间中攻击获得好的攻击效果。</li></ol><h3 id="Q5-：迁移性的理论相关？"><a href="#Q5-：迁移性的理论相关？" class="headerlink" title="Q5 ：迁移性的理论相关？"></a>Q5 ：迁移性的理论相关？</h3><p>目前理论尚待完善。</p><p>关于可迁移性的度量，由于迁移并不独立存在，一定是从一个模型到另一个模型，所以目前也无统一度量方法。</p><h3 id="Q6-：可证明的迁移攻击的防御"><a href="#Q6-：可证明的迁移攻击的防御" class="headerlink" title="Q6 ：可证明的迁移攻击的防御"></a>Q6 ：可证明的迁移攻击的防御</h3><p>由于目前迁移攻击的发展空间巨大（效果很差成功率很低），所以没有相关的防御。一般经过对抗训练就能很好地防御了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;观后感&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://scl.sribd.cn/seminar/index.html&quot;&gt;Source&lt;/a&gt; The 4th Lecture&lt;/p&gt;
&lt;h2 id=&quot;基于Spatial-Momentum的迁移性增强方法&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="AISP" scheme="https://cyccyyycyc.github.io/categories/AISP/"/>
    
    
    <category term="对抗样本" scheme="https://cyccyyycyc.github.io/tags/%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Deepfake by 吕思伟</title>
    <link href="https://cyccyyycyc.github.io/2022/10/18/Deepfake-by%E5%90%95%E6%80%9D%E4%BC%9F/"/>
    <id>https://cyccyyycyc.github.io/2022/10/18/Deepfake-by%E5%90%95%E6%80%9D%E4%BC%9F/</id>
    <published>2022-10-18T13:55:02.000Z</published>
    <updated>2022-10-21T03:49:49.871Z</updated>
    
    <content type="html"><![CDATA[<p>观后感</p><p><a href="http://scl.sribd.cn/seminar/index.html">Source</a> The 3td Lecture</p><h1 id="DEEP-FAKE"><a href="#DEEP-FAKE" class="headerlink" title="DEEP FAKE"></a>DEEP FAKE</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><ol><li>硬件近年来发展迅速，甚至超过了摩尔定律描述的速度。</li><li>互联网用户多，数据体量庞大，且传播较快较广泛。</li><li>AI发展迅速（其实是被大数据和高效的计算资源推着发展的）</li></ol><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><h3 id="GAN-based-Image"><a href="#GAN-based-Image" class="headerlink" title="GAN-based Image"></a>GAN-based Image</h3><p>生成的fake_images有如下目标：</p><ol><li>质量高，有逼真的特征细节纹理</li><li>种类多</li></ol><h3 id="DNN-based-Speech"><a href="#DNN-based-Speech" class="headerlink" title="DNN-based Speech"></a>DNN-based Speech</h3><ol><li>VC (voice conversion)：可以理解为风格转换，A的内容＋B的风格</li><li>TTS (Text to Speech)</li></ol><h3 id="AE-based-Video"><a href="#AE-based-Video" class="headerlink" title="AE-based Video"></a>AE-based Video</h3><p>理解为逐帧进行替换（风格转换）</p><p>Decoder 分离identity and message，Encode进行一个重新添加。</p><p>问题：耗费较多训练资源，目前还需要比较多的人为调整，而调整操作必然留下痕迹，这也利于检测。</p><h2 id="Impact"><a href="#Impact" class="headerlink" title="Impact"></a>Impact</h2><h3 id="Positive"><a href="#Positive" class="headerlink" title="Positive"></a>Positive</h3><ol><li>电影高难度动作、或者一些场景都可以进行生成</li><li>游戏、远程教育可以通过生成提高交互性</li><li>利于数字匿名化，隐藏个人的identity，可用于个人隐私保护</li><li>生成更具多样性的数据集</li></ol><h3 id="Negative-main"><a href="#Negative-main" class="headerlink" title="Negative(main)"></a>Negative(main)</h3><ol><li>制造假象，混淆视听，误导大众做出错误决策</li><li>降低公众对媒体的信任感，俗称一颗老鼠屎坏了一锅粥</li><li>信息量变大了，含金量并没有提高，信息流变得更为复杂。</li></ol><h2 id="Detection"><a href="#Detection" class="headerlink" title="Detection"></a>Detection</h2><p>虚假信息其实一直都存在，只是随着AI的发展，虚假信息流增强，更难以分辨且威胁性更大，由此Deep-Fake Detection愈发重要。</p><p>下图为吕思伟教授在讲座中给出的DeepFake Detection分类</p><p><img src="/.././images/deepfake-video-detection.jpg" alt="deepfake-video-detection"></p><p>首先明确DeepFake检测是一个二分类问题。</p><p>其次可分为Single-modality 和 Multi-modality。</p><p>目前主流是Single-modality  –&gt;  Frame-based  –&gt;  Data-driven的检测手段。</p><p>Cue可以理解为Feature：</p><ol><li>Signal cues：不关心内容，只关心数据本身构成。如Post-processing方法，即为检测生成fake_images后贴到视频里的后处理痕迹，鉴定是否为真。</li><li>Semantic cues：关心数据内容本身是否符合规律。如人脸各个组成的朝向是否正确，如眨眼频率。（个人感觉听起来可延展性较弱，貌似只能针对特定数据特定分布，而且开源后攻击者就可以注意到这个规律，生成符合特定规律的图像就可以骗过检测模型了）</li></ol><p>总体感觉，没有一个普适性的、统一的、可延展的完善的检测方法，较为零碎。</p><h2 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h2><ol><li>可解释性：随着Deep-Fake的负面影响越来越严重，除了需要检测出”鉴定为假“的结果，在实际应用中，往往不能单纯依靠机器判别，还需要给出假的理由。</li><li>目前检测方法从不同角度切入，种类很多，但可扩展性不强，缺乏一个统一的检测方法。攻击者可以很容易针对专门检测方法进行调整，绕过检测防御。</li><li>很多检测方法误判率较高。实际应用中容易影响用户体验感。</li><li>目前的检测手段实际上是一种事后的被动防御。现在很多人都有一致的想法，利用后门去破坏Deep-Fake的生成，进行主动防御。</li></ol><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><ol><li>生成范围逐渐扩展。不再局限于人脸，逐渐生成四肢、全身…</li><li>共同生成音效＋视频帧，更加逼真</li><li>逐步减少对数据的依赖。比如由单张图片生成动态的视频，由低维构建高维场景。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;观后感&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://scl.sribd.cn/seminar/index.html&quot;&gt;Source&lt;/a&gt; The 3td Lecture&lt;/p&gt;
&lt;h1 id=&quot;DEEP-FAKE&quot;&gt;&lt;a href=&quot;#DEEP-FAKE&quot; class=</summary>
      
    
    
    
    <category term="AISP" scheme="https://cyccyyycyc.github.io/categories/AISP/"/>
    
    
    <category term="DeepFake" scheme="https://cyccyyycyc.github.io/tags/DeepFake/"/>
    
  </entry>
  
  <entry>
    <title>深度学习反脆弱技术的攻防和测评By刘祥龙</title>
    <link href="https://cyccyyycyc.github.io/2022/10/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%8F%8D%E8%84%86%E5%BC%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E9%98%B2%E5%92%8C%E6%B5%8B%E8%AF%84By%E5%88%98%E7%A5%A5%E9%BE%99/"/>
    <id>https://cyccyyycyc.github.io/2022/10/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%8F%8D%E8%84%86%E5%BC%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E9%98%B2%E5%92%8C%E6%B5%8B%E8%AF%84By%E5%88%98%E7%A5%A5%E9%BE%99/</id>
    <published>2022-10-18T11:55:09.000Z</published>
    <updated>2022-10-21T03:50:55.386Z</updated>
    
    <content type="html"><![CDATA[<p>Source:</p><p><a href="http://scl.sribd.cn/seminar/index.html">论坛网站</a>The 2nd Lecture</p><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><h2 id="安全挑战"><a href="#安全挑战" class="headerlink" title="安全挑战"></a>安全挑战</h2><p>非人为刻意引发<br>网络安全，公共安全（安检、自动驾驶），国防安全（侦察、遥感监测）等</p><p>人为刻意构造的全新类型攻击<br>对抗样本、噪音污染、数据投毒、数据伪造、后门攻击…</p><h1 id="对抗样本"><a href="#对抗样本" class="headerlink" title="对抗样本"></a>对抗样本</h1><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>一类被恶意设计来攻击AI模型的样本</p><ol><li>与真实样本的差异不易感知</li><li>可以导致模型进行错误的判断</li></ol><p>“脆弱性在深度学习中具有普遍性”（Nature 2019）<br>本次主要从对抗样本角度出发关注深度学习的脆弱性。</p><h2 id="数字世界中的对抗样本"><a href="#数字世界中的对抗样本" class="headerlink" title="数字世界中的对抗样本"></a>数字世界中的对抗样本</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li>微小扰动，不易觉察</li><li>语义不变而欺骗模型</li></ol><h3 id="攻击分类"><a href="#攻击分类" class="headerlink" title="攻击分类"></a>攻击分类</h3><ol><li>黑盒攻击</li><li>白盒攻击</li></ol><h4 id="FGSM-attack-2014-基于梯度的攻击"><a href="#FGSM-attack-2014-基于梯度的攻击" class="headerlink" title="FGSM attack:2014,基于梯度的攻击"></a><a href="https://arxiv.org/abs/1412.6572">FGSM attack</a>:2014,基于梯度的攻击</h4><p>攻击假设：白盒，可以获得模型反向传播的梯度符号</p><p>特点<br>1.fast<br>2.sign</p><h4 id="C-amp-W-attack-2017-基于优化的攻击"><a href="#C-amp-W-attack-2017-基于优化的攻击" class="headerlink" title="C&amp;W attack:2017,基于优化的攻击"></a><a href="https://arxiv.org/abs/1608.04644">C&amp;W attack</a>:2017,基于优化的攻击</h4><p>攻击假设：白盒，攻击者需要获得模型数据</p><p>数学理解<br>D：distance<br>C：classification<br>f: 目标函数。当且仅当 f(x+δ)≤0时, C(x+δ)&#x3D;t</p><p>函数连续：因为要进行优化，所以目标函数需要是光滑连续有梯度的。<br>slow：因为涉及多步优化计算w，所以速度相对较慢。</p><h4 id="PBBA-2017-基于迁移的攻击"><a href="#PBBA-2017-基于迁移的攻击" class="headerlink" title="PBBA:2017,基于迁移的攻击"></a><a href="https://arxiv.org/abs/1602.02697">PBBA</a>:2017,基于迁移的攻击</h4><ol><li>攻击假设：黑盒</li><li>对代理模型的攻击迁移到其它模型</li></ol><h4 id="AdvGAN-2018-基于模型的攻击"><a href="#AdvGAN-2018-基于模型的攻击" class="headerlink" title="AdvGAN:2018,基于模型的攻击"></a><a href="https://arxiv.org/abs/1801.02610">AdvGAN</a>:2018,基于模型的攻击</h4><p>攻击假设：白盒生成，需要获得受害者模型数据来计算adv-L</p><h4 id="其它任务"><a href="#其它任务" class="headerlink" title="其它任务"></a>其它任务</h4><h5 id="Video-Analysis"><a href="#Video-Analysis" class="headerlink" title="Video Analysis"></a>Video Analysis</h5><p>视频逐帧攻击</p><h5 id="Speech-Recognition"><a href="#Speech-Recognition" class="headerlink" title="Speech Recognition"></a>Speech Recognition</h5><h5 id="Natural-Language-Processing"><a href="#Natural-Language-Processing" class="headerlink" title="Natural Language Processing"></a>Natural Language Processing</h5><p>自然语言处理领域的对抗样本：<br>对于人类，语序不影响阅读，而文本字母顺序的调换会让模型输出错误的结果。</p><h5 id="Reinforcement-Learning"><a href="#Reinforcement-Learning" class="headerlink" title="Reinforcement Learning"></a>Reinforcement Learning</h5><p>强化学习领域对抗样本的运用实际上是对策略的攻击<br>一种理解是模型本身不够完善，没有学习到如何应对这个策略</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><h2 id="物理世界中的对抗样本"><a href="#物理世界中的对抗样本" class="headerlink" title="物理世界中的对抗样本"></a>物理世界中的对抗样本</h2><p>物理世界对抗样本：改造物理实体以进行攻击<br>受限于：感知器质量、光照强度、远近距离…<br>与数字世界对抗样本相比，物理世界对抗样本具有黑盒特性，更复杂，危险性更大</p><p>根据数字世界和物理世界的差异，给出对抗样本泛化定义：<br>1.对于人类，视觉上具备友好性 For human, it disguises as a normal example.<br>2.对于模型具有攻击性，可以欺骗模型 For models, it misleads the model predictions</p><h2 id="反脆弱技术体系"><a href="#反脆弱技术体系" class="headerlink" title="反脆弱技术体系"></a>反脆弱技术体系</h2><h3 id="脆弱性原理"><a href="#脆弱性原理" class="headerlink" title="脆弱性原理"></a>脆弱性原理</h3><p>从关键决策路径动态地来看：<br>关键攻击路径刻画了从输入端到决策输出端错误输出的传播路径，这是对模型泛化应用影响最大的路径。<br>表明神经网络中存在脆弱单元，脆弱路径。</p><p>从注意力机制来看：<br>模式识别存在一定偏好，可能对特定的特征（如纹理）有一定偏好（理解为容易激活）</p><h3 id="脆弱性检测"><a href="#脆弱性检测" class="headerlink" title="脆弱性检测"></a>脆弱性检测</h3><p>深度学习网络的对抗鲁棒性和自然噪音鲁棒性往往呈现正相关。提高对抗鲁棒性利于整体鲁棒性的优化，这需要完备数据集的支撑。</p><p>问题：人工智能要想获得广泛使用，成为基础设施，就要有可靠性的保证。<br>挑战：建立完善的评估指标、技术规范和工具集，去测试其模型的可靠性。</p><h3 id="反脆弱加固"><a href="#反脆弱加固" class="headerlink" title="反脆弱加固"></a>反脆弱加固</h3><h4 id="数据端"><a href="#数据端" class="headerlink" title="数据端"></a>数据端</h4><p>过滤有害数据，但没有优化模型本身的反脆弱能力。</p><h5 id="1-污染检测"><a href="#1-污染检测" class="headerlink" title="1.污染检测"></a>1.污染检测</h5><p>对于数据进行domain迁移，数据增强，提高模型泛化能力</p><h5 id="2-污染抑制"><a href="#2-污染抑制" class="headerlink" title="2.污染抑制"></a>2.污染抑制</h5><p>增加防御补丁</p><h5 id="3-污染抑制"><a href="#3-污染抑制" class="headerlink" title="3.污染抑制"></a>3.污染抑制</h5><p>利用W-Distance来进行数据增强，提高模型泛化能力</p><h4 id="模型端：提高鲁棒性"><a href="#模型端：提高鲁棒性" class="headerlink" title="模型端：提高鲁棒性"></a>模型端：提高鲁棒性</h4><h5 id="1-训练加固"><a href="#1-训练加固" class="headerlink" title="1.训练加固"></a>1.训练加固</h5><p>模型单元增强：在中间层注入多样化的对抗噪音，提高鲁棒性，使其学习到更多的语义信息</p><h5 id="2-结构优化："><a href="#2-结构优化：" class="headerlink" title="2.结构优化："></a>2.结构优化：</h5><p>抑制脆弱路径：剪枝，压缩，稀疏化，量化，一定程度上可以抑制噪音<br>中心加权归一化BN进行神经网络模型数据分布整合，提高模型分布的稳定性和收敛性，改善了曲率</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><ul><li>如何平衡模型的精确性和鲁棒性？<br>模型的精确性和鲁棒性使多因素共同作用下的结果，应该全面分析不同因素作用，综合考量设计优化目标</li><li>一种设想：大网络下的特定子网络结构具有鲁棒性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Source:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://scl.sribd.cn/seminar/index.html&quot;&gt;论坛网站&lt;/a&gt;The 2nd Lecture&lt;/p&gt;
&lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="AISP" scheme="https://cyccyyycyc.github.io/categories/AISP/"/>
    
    
    <category term="对抗样本" scheme="https://cyccyyycyc.github.io/tags/%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理</title>
    <link href="https://cyccyyycyc.github.io/2022/10/18/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    <id>https://cyccyyycyc.github.io/2022/10/18/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</id>
    <published>2022-10-18T11:32:23.000Z</published>
    <updated>2022-10-21T03:50:48.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图像基础"><a href="#图像基础" class="headerlink" title="图像基础"></a>图像基础</h3><h4 id="图片表示"><a href="#图片表示" class="headerlink" title="图片表示"></a>图片表示</h4><h5 id="二值图"><a href="#二值图" class="headerlink" title="二值图"></a>二值图</h5><p>只有2种取值</p><h5 id="灰度图"><a href="#灰度图" class="headerlink" title="灰度图"></a>灰度图</h5><p>unit8</p><p>8位灰度图（0~255）</p><p>二维矩阵（一个通道）</p><h5 id="彩色图"><a href="#彩色图" class="headerlink" title="彩色图"></a>彩色图</h5><p>三维矩阵（RGB三个通道）</p><p>真彩色</p><h3 id="通道的分离和合并"><a href="#通道的分离和合并" class="headerlink" title="通道的分离和合并"></a>通道的分离和合并</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img_bgr = cv.imread(img_path)</span><br><span class="line"><span class="comment"># 通道分离</span></span><br><span class="line">b, g, r = cv.split(img_bgr)</span><br><span class="line"><span class="comment"># 通道合并</span></span><br><span class="line">img_rgb = cv.merge([r, g, b])</span><br></pre></td></tr></table></figure><h3 id="彩色图转换成灰度图"><a href="#彩色图转换成灰度图" class="headerlink" title="彩色图转换成灰度图"></a>彩色图转换成灰度图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三通道按权值加权 0.299 0.587 0.114</span></span><br><span class="line">gray1 = <span class="number">0.299</span> * r + <span class="number">0.587</span> *g + <span class="number">0.114</span> *b</span><br><span class="line"><span class="comment"># dtype = uint8</span></span><br><span class="line">gray2 = np.uint8(gray1)</span><br><span class="line">gray3 = gray1.astype(np.uint8)</span><br><span class="line"></span><br><span class="line">gray4 = cv.cvtColor(img_bgr, cv.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure><h3 id="图像二值化"><a href="#图像二值化" class="headerlink" title="图像二值化"></a>图像二值化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thresh = <span class="number">125</span></span><br><span class="line">gray4[gray4 &gt; thresh] = <span class="number">255</span></span><br><span class="line">gray4[gray4 &lt;= thresh] = <span class="number">0</span></span><br><span class="line"><span class="comment"># gray4 已经被二值化</span></span><br><span class="line"></span><br><span class="line">ignore, img_bin = cv.threshold(gray_uint8_img, th1, th2, cv.THRESH_BINARY)</span><br></pre></td></tr></table></figure><h3 id="图像运算"><a href="#图像运算" class="headerlink" title="图像运算"></a>图像运算</h3><h5 id="图像相加"><a href="#图像相加" class="headerlink" title="图像相加"></a>图像相加</h5><p>混合图像、添加噪声</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dtype = float64</span></span><br><span class="line">img_add1 = cv.add(img1*<span class="number">0.5</span>, img2*<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dtype = uint8</span></span><br><span class="line">img_add2 = cv.addWeighted(img1, alpha, img2, beta, gamma)</span><br></pre></td></tr></table></figure><h5 id="图像相减"><a href="#图像相减" class="headerlink" title="图像相减"></a>图像相减</h5><p>消除背景、差影法（比较差异，运动跟踪）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_sub = cv.subtract(img1, img2)</span><br></pre></td></tr></table></figure><h5 id="图像相乘"><a href="#图像相乘" class="headerlink" title="图像相乘"></a>图像相乘</h5><p>掩膜mask</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv.multiply(img1, img2)</span><br></pre></td></tr></table></figure><h5 id="图像相除"><a href="#图像相除" class="headerlink" title="图像相除"></a>图像相除</h5><p>校正设备、比较差异</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv.divide(img1, img2)</span><br></pre></td></tr></table></figure><h3 id="图像变换"><a href="#图像变换" class="headerlink" title="图像变换"></a>图像变换</h3><h5 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h5><p>$$<br>s&#x3D;b+kr<br>$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv.convertScaleAbs(img, alpha=1, beta=0)</span><br></pre></td></tr></table></figure><h5 id="非线性变换"><a href="#非线性变换" class="headerlink" title="非线性变换"></a>非线性变换</h5><p>$$<br>s&#x3D;a+\frac{ln(r+1)}{blnc}<br>$$</p><h5 id="Gamma变换"><a href="#Gamma变换" class="headerlink" title="Gamma变换"></a>Gamma变换</h5><p>$$<br>s&#x3D;cr^y<br>$$</p><p>y越大图像越亮</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = img / <span class="number">255</span></span><br><span class="line">img = np.power(img, y) * <span class="number">255</span></span><br></pre></td></tr></table></figure><h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><h5 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># numpy</span></span><br><span class="line">img = cv.imread(img_path)</span><br><span class="line"><span class="comment"># h * w * c</span></span><br><span class="line"><span class="comment"># y * x *c</span></span><br><span class="line">img = img[<span class="number">20</span>:<span class="number">100</span>, <span class="number">100</span>:<span class="number">200</span>, :]</span><br></pre></td></tr></table></figure><h5 id="放缩"><a href="#放缩" class="headerlink" title="放缩"></a>放缩</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OpenCv</span></span><br><span class="line"><span class="comment"># (x, y)=(w, h)=(500,400)</span></span><br><span class="line">img = cv.resize(img, (<span class="number">500</span>, <span class="number">400</span>))</span><br></pre></td></tr></table></figure><h5 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h5><p>仿射变换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 坐标的映射矩阵M</span></span><br><span class="line">M = np.array([...], dtype=np.float32)</span><br><span class="line">cv.warpAffine(img, M, dsize)</span><br></pre></td></tr></table></figure><h5 id="错切变换"><a href="#错切变换" class="headerlink" title="错切变换"></a>错切变换</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M = np.array([...], dtype=np.float32)</span><br><span class="line">img = cv.warpAffine(img, M, dsize)</span><br></pre></td></tr></table></figure><h5 id="镜像变换"><a href="#镜像变换" class="headerlink" title="镜像变换"></a>镜像变换</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵</span></span><br><span class="line">M = np.array([...], dtype=np.float32)</span><br><span class="line">img = cv.warpAffine(img, M, dsize)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 垂直镜像</span></span><br><span class="line">cv.flip(img, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 水平镜像</span></span><br><span class="line">cv.flip(img, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时进行</span></span><br><span class="line">cv.flit(img, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h5 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 旋转矩阵</span></span><br><span class="line">M = np.array([...], dtype=np.float32)</span><br><span class="line">img = cv.warpAffine(img, M, dsize)</span><br><span class="line"></span><br><span class="line"><span class="comment"># M = cv.getRotationMatrix2D(center, angle, scale)</span></span><br><span class="line">h, w, c = img.shape</span><br><span class="line"><span class="comment"># center = (x, y)</span></span><br><span class="line">M = cv.getRotationMatrix2D((w//<span class="number">2</span>, h//<span class="number">2</span>), <span class="number">45</span>)</span><br><span class="line">img = cv.warpAffine(img, M, dsize)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺时针逆时针旋转90°</span></span><br><span class="line">img_rotate = cv.rotate(img, cv.ROTATE_90_CLOCKWISE)</span><br></pre></td></tr></table></figure><h5 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M = cv.getPerspectiveTransform(src, dst)</span><br><span class="line">img = cv.warpPerspective(img, M, dsize)</span><br></pre></td></tr></table></figure><h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><p>像素值没变，像素位置变了。<br>所以实际上计算了一个坐标变换的矩阵M。</p><h5 id="最近邻插值"><a href="#最近邻插值" class="headerlink" title="最近邻插值"></a>最近邻插值</h5><p>逆向思维：小图插值变大图 —&gt; 大图变小图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv.resize(img, dsize, interpolation=cv.INTER_NEAREST)</span><br></pre></td></tr></table></figure><h5 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h5><p>考虑邻近的像素点，按照权值计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv.resize(img, dsize, interpolation=cv.INTER_LINEAR_EXACT)</span><br></pre></td></tr></table></figure><h3 id="图像模糊"><a href="#图像模糊" class="headerlink" title="图像模糊"></a>图像模糊</h3><h5 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv.filter2D(img, -<span class="number">1</span>, kernel)</span><br></pre></td></tr></table></figure><h5 id="均值模糊"><a href="#均值模糊" class="headerlink" title="均值模糊"></a>均值模糊</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv.blur(img, (<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">cv.boxFilter(img, -<span class="number">1</span>, (<span class="number">5</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure><h5 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.medianBlur(img, <span class="number">3</span>)  <span class="comment"># 奇数</span></span><br></pre></td></tr></table></figure><h5 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sigma 方差</span></span><br><span class="line"><span class="comment"># 方差小则copy原图</span></span><br><span class="line"><span class="comment"># 方差大则和均值滤波差不多</span></span><br><span class="line">cv.GaussianBlur(img, (<span class="number">5</span>,<span class="number">5</span>), sigmaX)</span><br></pre></td></tr></table></figure><h5 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h5><p>一般模糊会丢失边缘信息，而双边滤波可以保留边缘高频信息，平滑颜色相近的地方。</p><p>需要一直更新卷积核的值：</p><ol><li>距离越远，加权值越小</li><li>颜色差异越大，加权值越小</li></ol><p>缺点：对高频噪声无滤波效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.bilateralFilter(img, -1, sigmaColor=50, sigmaSpace=3)</span><br></pre></td></tr></table></figure><h3 id="图像边缘"><a href="#图像边缘" class="headerlink" title="图像边缘"></a>图像边缘</h3><p>……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;图像基础&quot;&gt;&lt;a href=&quot;#图像基础&quot; class=&quot;headerlink&quot; title=&quot;图像基础&quot;&gt;&lt;/a&gt;图像基础&lt;/h3&gt;&lt;h4 id=&quot;图片表示&quot;&gt;&lt;a href=&quot;#图片表示&quot; class=&quot;headerlink&quot; title=&quot;图片表示&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="cv" scheme="https://cyccyyycyc.github.io/categories/cv/"/>
    
    
  </entry>
  
</feed>
