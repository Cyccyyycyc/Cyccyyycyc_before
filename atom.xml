<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cy</title>
  
  
  <link href="https://cyccyyycyc.github.io/atom.xml" rel="self"/>
  
  <link href="https://cyccyyycyc.github.io/"/>
  <updated>2022-10-26T08:56:23.432Z</updated>
  <id>https://cyccyyycyc.github.io/</id>
  
  <author>
    <name>Cy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Adversarial Robustness by刘思佳</title>
    <link href="https://cyccyyycyc.github.io/2022/10/26/Adversarial-Robustness-by%E5%88%98%E6%80%9D%E4%BD%B3/"/>
    <id>https://cyccyyycyc.github.io/2022/10/26/Adversarial-Robustness-by%E5%88%98%E6%80%9D%E4%BD%B3/</id>
    <published>2022-10-26T08:31:59.000Z</published>
    <updated>2022-10-26T08:56:23.432Z</updated>
    
    <content type="html"><![CDATA[<p>观后感</p><p><a href="http://scl.sribd.cn/seminar/index.html">Source</a> The 6th Lecture</p><h1 id="深度神经网络的对抗鲁棒性"><a href="#深度神经网络的对抗鲁棒性" class="headerlink" title="深度神经网络的对抗鲁棒性"></a>深度神经网络的对抗鲁棒性</h1><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><h3 id="ZO-SGD"><a href="#ZO-SGD" class="headerlink" title="ZO-SGD"></a>ZO-SGD</h3><p>对于黑盒的对抗攻击，优化问题不能求导，便将其转化为一个零阶(ZO zero-order)优化问题，他们证明了收敛性。</p><p>但是存在收敛速度慢的问题：</p><ol><li>有偏差bias</li><li>方差较大</li><li>容易受到维度的影响，高维下收敛速度太慢。</li></ol><h3 id="ZO-signSGD"><a href="#ZO-signSGD" class="headerlink" title="ZO-signSGD"></a>ZO-signSGD</h3><p>相比于ZO-SGD，ZO-signSGD对估计的梯度取了正负。</p><p>效果：</p><ol><li>减少了估计的方差</li><li>收敛速度增加</li></ol><p>但是同时也引入了新的问题：收敛精度下降，难以取得和ZO-SGD一样的最值。</p><h3 id="ZO-Adam"><a href="#ZO-Adam" class="headerlink" title="ZO-Adam"></a>ZO-Adam</h3><p>sign减少估计的方差，而换一种思路，自适应的学习率adaptive learning rate也可以降低估计方差。因此可以采用ZO-Adam优化方法。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>对抗攻击会修改图片的interpretation maps （CAM），造成了可解释性上的差异。</p><p>由此，刘思佳教授设计相应的可解释性上的距离度量，并证明了该距离大于图片对原本类和目标类的激活值之差。 </p><p>将可解释性距离度量用于对抗训练，对有较大扰动的对抗攻击的鲁棒性提高效果很好，但是会使模型的精确性下降。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><ol><li>不同领域之间的鲁棒性的迁移性</li><li>大规模鲁棒训练</li><li>与传统信息安全领域交叉的鲁棒机器学习</li><li>攻击逆向工程与对攻击者意图探明</li><li>对抗鲁棒性与神经网络多种性质之间的关系</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;观后感&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://scl.sribd.cn/seminar/index.html&quot;&gt;Source&lt;/a&gt; The 6th Lecture&lt;/p&gt;
&lt;h1 id=&quot;深度神经网络的对抗鲁棒性&quot;&gt;&lt;a href=&quot;#深度神经网络的对抗鲁棒性&quot; </summary>
      
    
    
    
    <category term="AISP" scheme="https://cyccyyycyc.github.io/categories/AISP/"/>
    
    
    <category term="对抗鲁棒性" scheme="https://cyccyyycyc.github.io/tags/%E5%AF%B9%E6%8A%97%E9%B2%81%E6%A3%92%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Towards Robust Representation by谢慈航</title>
    <link href="https://cyccyyycyc.github.io/2022/10/26/Towards-Robust-Representation-by%E8%B0%A2%E6%85%88%E8%88%AA/"/>
    <id>https://cyccyyycyc.github.io/2022/10/26/Towards-Robust-Representation-by%E8%B0%A2%E6%85%88%E8%88%AA/</id>
    <published>2022-10-26T07:25:03.000Z</published>
    <updated>2022-10-26T08:22:44.699Z</updated>
    
    <content type="html"><![CDATA[<p>观后感</p><p><a href="http://scl.sribd.cn/seminar/index.html">Source</a> The 5th Lecture</p><h1 id="鲁棒表示学习"><a href="#鲁棒表示学习" class="headerlink" title="鲁棒表示学习"></a>鲁棒表示学习</h1><p>AI下的DL分支目前发展迅猛，应用效果好，如：</p><ol><li>AlphaGo</li><li>Rubik’s Cube（机器人解魔方）</li><li>Self-Driving Cars(如特斯拉)</li><li>…</li></ol><p>而2013年对抗样本首次被提出，暴露了AI的脆弱性，也引发了人们的思考和关注：AI为什么不鲁棒？？</p><h2 id="脆弱性-Vuluerability"><a href="#脆弱性-Vuluerability" class="headerlink" title="脆弱性 Vuluerability"></a>脆弱性 Vuluerability</h2><p>（1）对抗样本影响各个领域：</p><ol><li>分类</li><li>语义分割</li><li>目标检测</li><li>强化学习</li><li>Pose Estimation</li><li>…</li></ol><p>（2）对抗样本具有一定迁移性：不同任务之间的对抗样本可以相互迁移</p><p>在黑盒攻击中，一个思路是利用对抗样本的迁移性。在本地代理模型Substitute Networks上生成对抗样本，用以迁移攻击目标模型。</p><p>（3）物理世界的对抗样本存在较大威胁性</p><h2 id="修改结构：鲁棒性提高"><a href="#修改结构：鲁棒性提高" class="headerlink" title="修改结构：鲁棒性提高"></a>修改结构：鲁棒性提高</h2><h3 id="中间层去噪"><a href="#中间层去噪" class="headerlink" title="中间层去噪"></a>中间层去噪</h3><p>一个现象是：在pix级别原图和对抗样本没有很大区别，但经过神经网络的放大处理，在feature map上呈现出比较大的差异。（如deepfake检测）</p><ol><li><p>中间层去噪：可以将图片去噪的经典方法（如中值滤波、均值滤波…）应用在中间层，防御对抗攻击。这个操作是为了提高模型鲁棒性，相应地，去噪操作会导致信息损失，模型精确度下降。</p></li><li><p>Denoising Block Design：对应优化模型架构，采用ResNet结构减少信息损失，提高模型精确度。</p></li></ol><h3 id="平滑的Function"><a href="#平滑的Function" class="headerlink" title="平滑的Function"></a>平滑的Function</h3><p>往往鲁棒性对应着平滑连续的表示函数。Relu存在跳跃，可以采用一些连续平滑的激活函数（如GElu，Elu，SmoothRelu…)来增强鲁棒性。</p><h2 id="用对抗样本进行数据增强"><a href="#用对抗样本进行数据增强" class="headerlink" title="用对抗样本进行数据增强"></a>用对抗样本进行数据增强</h2><p>进行数据增强有很多方法：</p><ol><li>很多方法都不具有普适性（如flip这样的处理，对于NLP, 强化学习等领域是不适用的）</li><li>对抗样本进行数据增强是一种通用的方法。</li></ol><h3 id="对抗训练"><a href="#对抗训练" class="headerlink" title="对抗训练"></a>对抗训练</h3><p>一般而言，对抗训练有时候会导致模型鲁棒性上升精确度下降。有一种思路是，先用对抗样本进行对抗训练后再用干净样本进行fine-tuning来提高准确度，但是这样模型可能会以往对抗训练中学到的东西。</p><h3 id="Adv-Prop"><a href="#Adv-Prop" class="headerlink" title="Adv-Prop"></a>Adv-Prop</h3><p>以前就有人提出，训练时将对抗样本和正常样本同时输入网络（2个BN分别归一化处理，其它不做修改）。测试时丢掉对抗样本对应的BN，只要干净样本对应的BN。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>构建人和机器之间的合作，可解释性是一个重要的问题。我们需要知道AI何时可以解决问题，什么场景下会出Bug，很多时候，对于输出的结果（如分类的结果），我们更需要它给出原因，是依据什么得出了这个输出。</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>（1）可以从什么角度出发来提高模型鲁棒性？</p><ol><li>数据：对抗训练学到更多特征</li><li>结构：更加平滑的函数表示</li><li>损失函数：损失函数解决了模型如何训练的问题。</li></ol><p>这三者的优化是并行的。</p><p>（2）鲁棒性和泛化性的关系</p><p>对抗样本是一个子问题，是特殊的关系。</p><p>（3）鲁棒性和准确性是否矛盾？</p><p>在cv领域，用对抗样本进行数据增强往往会导致鲁棒性上升而准确性下降。而在NLP领域，由于数据多、模型大，它们的表征能力capacity往往更强，进行对抗训练往往是鲁棒性和准确性同时提升的。</p><p>（4）普通分类错误的样本和对抗样本有什么区别？</p><p>谢教授说他不会，可以思考下。</p><p>或许普遍意义上没有区别，感觉都是没学到足够的特征。乱说的，以后想到了来修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;观后感&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://scl.sribd.cn/seminar/index.html&quot;&gt;Source&lt;/a&gt; The 5th Lecture&lt;/p&gt;
&lt;h1 id=&quot;鲁棒表示学习&quot;&gt;&lt;a href=&quot;#鲁棒表示学习&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="AISP" scheme="https://cyccyyycyc.github.io/categories/AISP/"/>
    
    
    <category term="对抗样本" scheme="https://cyccyyycyc.github.io/tags/%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>intersection-of-two-linked-lists</title>
    <link href="https://cyccyyycyc.github.io/2022/10/26/intersection-of-two-linked-lists/"/>
    <id>https://cyccyyycyc.github.io/2022/10/26/intersection-of-two-linked-lists/</id>
    <published>2022-10-26T02:22:35.000Z</published>
    <updated>2022-10-26T02:30:51.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="intersection-of-two-linked-lists"><a href="#intersection-of-two-linked-lists" class="headerlink" title="intersection-of-two-linked-lists"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">intersection-of-two-linked-lists</a></h1><p>相交链表</p><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><h2 id="哈希字典"><a href="#哈希字典" class="headerlink" title="哈希字典"></a>哈希字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dic = <span class="built_in">set</span>()</span><br><span class="line">        p = headA</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            dic.add(p)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        p = headB</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>$$<br>a+(b-c)&#x3D;b+(a-c)&#x3D;a+b-c<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        p, q = headA, headB</span><br><span class="line">        <span class="keyword">while</span> q != p:</span><br><span class="line">            p = p.<span class="built_in">next</span> <span class="keyword">if</span> p <span class="keyword">else</span> headB</span><br><span class="line">            q = q.<span class="built_in">next</span> <span class="keyword">if</span> q <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure><h2 id="去尾"><a href="#去尾" class="headerlink" title="去尾"></a>去尾</h2><p>对两个链表，裁剪最大相同长度的尾部，同时遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        p, q = headA, headB</span><br><span class="line">        la, lb = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 计算链表A长度</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            la += <span class="number">1</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 计算链表B长度</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            lb +=<span class="number">1</span></span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 裁剪去头</span></span><br><span class="line">        <span class="keyword">while</span> la &gt; lb:</span><br><span class="line">            headA = headA.<span class="built_in">next</span></span><br><span class="line">            la -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lb &gt; la:</span><br><span class="line">            headB = headB.<span class="built_in">next</span></span><br><span class="line">            lb -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 此时la==lb</span></span><br><span class="line">        p, q = headA, headB</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> q:</span><br><span class="line">            <span class="keyword">if</span> p==q:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;intersection-of-two-linked-lists&quot;&gt;&lt;a href=&quot;#intersection-of-two-linked-lists&quot; class=&quot;headerlink&quot; title=&quot;intersection-of-two-linked-l</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>minimum-depth-of-binary-tree</title>
    <link href="https://cyccyyycyc.github.io/2022/10/26/minimum-depth-of-binary-tree/"/>
    <id>https://cyccyyycyc.github.io/2022/10/26/minimum-depth-of-binary-tree/</id>
    <published>2022-10-26T02:13:14.000Z</published>
    <updated>2022-10-26T02:21:01.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="minimum-depth-of-binary-tree"><a href="#minimum-depth-of-binary-tree" class="headerlink" title="minimum-depth-of-binary-tree"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">minimum-depth-of-binary-tree</a></h1><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到<strong>最近叶子节点</strong>的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.right <span class="keyword">and</span> root.left:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(self.minDepth(root.left), self.minDepth(root.right)) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> self.minDepth(root.right) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                <span class="keyword">return</span> self.minDepth(root.left) + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 遇到叶子结点则返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            q = [root]</span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                depth += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                    tmp = q[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">del</span> q[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">if</span> tmp.left:</span><br><span class="line">                        q.append(tmp.left)</span><br><span class="line">                    <span class="keyword">if</span> tmp.right:</span><br><span class="line">                        q.append(tmp.right)</span><br><span class="line">                    <span class="comment"># 遇到叶子结点则返回深度</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> tmp.right <span class="keyword">and</span> <span class="keyword">not</span> tmp.left:</span><br><span class="line">                        <span class="keyword">return</span> depth</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;minimum-depth-of-binary-tree&quot;&gt;&lt;a href=&quot;#minimum-depth-of-binary-tree&quot; class=&quot;headerlink&quot; title=&quot;minimum-depth-of-binary-tree&quot;&gt;&lt;/a&gt;&lt;a</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</title>
    <link href="https://cyccyyycyc.github.io/2022/10/26/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/"/>
    <id>https://cyccyyycyc.github.io/2022/10/26/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</id>
    <published>2022-10-26T02:08:08.000Z</published>
    <updated>2022-10-26T02:11:06.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof"><a href="#lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof" class="headerlink" title="lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof"></a><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a></h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthFromEnd</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof&quot;&gt;&lt;a href=&quot;#lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof&quot; class=&quot;headerlink&quot; title=&quot;lian</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>majority-element</title>
    <link href="https://cyccyyycyc.github.io/2022/10/26/majority-element/"/>
    <id>https://cyccyyycyc.github.io/2022/10/26/majority-element/</id>
    <published>2022-10-26T01:37:48.000Z</published>
    <updated>2022-10-26T02:06:54.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="majority-element"><a href="#majority-element" class="headerlink" title="majority-element"></a><a href="https://leetcode.cn/problems/majority-element/">majority-element</a></h1><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序后取nums[n&#x2F;&#x2F;2]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">       <span class="keyword">return</span> Counter(nums).most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">       counts = collections.Counter(nums)</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">max</span>(counts.keys(), key=counts.get)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">set</span>(nums), key=nums.count)</span><br></pre></td></tr></table></figure><h2 id="摩尔投票"><a href="#摩尔投票" class="headerlink" title="摩尔投票"></a>摩尔投票</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        candidate = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 票数为0换候选人</span></span><br><span class="line">            <span class="keyword">if</span> count==<span class="number">0</span>:</span><br><span class="line">                candidate = num</span><br><span class="line">            count += (<span class="number">1</span> <span class="keyword">if</span> candidate == num <span class="keyword">else</span> -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure><h1 id="majority-element-ii"><a href="#majority-element-ii" class="headerlink" title="majority-element-ii"></a><a href="https://leetcode.cn/problems/majority-element-ii/">majority-element-ii</a></h1><p>给定一个大小为 <em>n</em> 的整数数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。</p><h2 id="摩尔投票-1"><a href="#摩尔投票-1" class="headerlink" title="摩尔投票"></a>摩尔投票</h2><p>选出2个有希望超过⌊ n&#x2F;3 ⌋的候选人，统计他们的票数是否真的超过⌊ n&#x2F;3 ⌋。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        vote1 = <span class="number">0</span></span><br><span class="line">        vote2 = <span class="number">0</span></span><br><span class="line">        candidate1 = <span class="literal">None</span></span><br><span class="line">        candidate2 = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num==candidate1:</span><br><span class="line">                vote1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num==candidate2:</span><br><span class="line">                vote2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> vote1==<span class="number">0</span>:</span><br><span class="line">                vote1 = <span class="number">1</span></span><br><span class="line">                candidate1 = num</span><br><span class="line">            <span class="keyword">elif</span> vote2==<span class="number">0</span>:</span><br><span class="line">                vote2 = <span class="number">1</span></span><br><span class="line">                candidate2 = num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vote1 -= <span class="number">1</span></span><br><span class="line">                vote2 -= <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        cnt1, cnt2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> vote1&gt;<span class="number">0</span> <span class="keyword">and</span> num==candidate1:</span><br><span class="line">                cnt1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> vote2&gt;<span class="number">0</span> <span class="keyword">and</span> num==candidate2:</span><br><span class="line">                cnt2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt1 &gt; <span class="built_in">len</span>(nums)//<span class="number">3</span>:</span><br><span class="line">            res.append(candidate1)</span><br><span class="line">        <span class="keyword">if</span> cnt2 &gt; <span class="built_in">len</span>(nums)//<span class="number">3</span>:</span><br><span class="line">            res.append(candidate2)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="哈希字典"><a href="#哈希字典" class="headerlink" title="哈希字典"></a>哈希字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> dic:</span><br><span class="line">                dic[num] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dic.keys():</span><br><span class="line">            <span class="keyword">if</span> dic[i] &gt; <span class="built_in">len</span>(nums)//<span class="number">3</span> :</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;majority-element&quot;&gt;&lt;a href=&quot;#majority-element&quot; class=&quot;headerlink&quot; title=&quot;majority-element&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>single-number</title>
    <link href="https://cyccyyycyc.github.io/2022/10/26/single-number/"/>
    <id>https://cyccyyycyc.github.io/2022/10/26/single-number/</id>
    <published>2022-10-26T01:32:48.000Z</published>
    <updated>2022-10-26T01:37:16.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="single-number"><a href="#single-number" class="headerlink" title="single-number"></a><a href="https://leetcode.cn/problems/single-number/">single-number</a></h1><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><ol><li>任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0&#x3D;a。</li><li>任何数和其自身做异或运算，结果是 0，即a⊕a&#x3D;0。</li><li>异或运算满足交换律。</li></ol><p>因此，把所有数值做异或运算即可得到结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            ans = ans ^ nums[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;single-number&quot;&gt;&lt;a href=&quot;#single-number&quot; class=&quot;headerlink&quot; title=&quot;single-number&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/single-nu</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>shu-zu-zhong-zhong-fu-de-shu-zi-lcof</title>
    <link href="https://cyccyyycyc.github.io/2022/10/26/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/"/>
    <id>https://cyccyyycyc.github.io/2022/10/26/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</id>
    <published>2022-10-26T01:25:40.000Z</published>
    <updated>2022-10-26T01:31:59.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shu-zu-zhong-zhong-fu-de-shu-zi-lcof"><a href="#shu-zu-zhong-zhong-fu-de-shu-zi-lcof" class="headerlink" title="shu-zu-zhong-zhong-fu-de-shu-zi-lcof"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">shu-zu-zhong-zhong-fu-de-shu-zi-lcof</a></h1><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><h2 id="哈希字典"><a href="#哈希字典" class="headerlink" title="哈希字典"></a>哈希字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRepeatNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic = <span class="built_in">set</span>() </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums), <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic.add(nums[i])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="原地交换"><a href="#原地交换" class="headerlink" title="原地交换"></a>原地交换</h2><p>数组长度为n，数字范围在[0, n-1]，且有数字重复。所以可以调整索引数值一一对应，当发生冲突则返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRepeatNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i:</span><br><span class="line">                <span class="keyword">if</span> nums[nums[i]] == nums[i]:</span><br><span class="line">                    <span class="keyword">return</span> nums[i]</span><br><span class="line">                nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;shu-zu-zhong-zhong-fu-de-shu-zi-lcof&quot;&gt;&lt;a href=&quot;#shu-zu-zhong-zhong-fu-de-shu-zi-lcof&quot; class=&quot;headerlink&quot; title=&quot;shu-zu-zhong-zhong-f</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>binary-search</title>
    <link href="https://cyccyyycyc.github.io/2022/10/25/binary-search/"/>
    <id>https://cyccyyycyc.github.io/2022/10/25/binary-search/</id>
    <published>2022-10-25T11:23:44.000Z</published>
    <updated>2022-10-25T11:27:27.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="binary-search"><a href="#binary-search" class="headerlink" title="binary-search"></a><a href="https://leetcode.cn/problems/binary-search/">binary-search</a></h1><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><h2 id="手写二分"><a href="#手写二分" class="headerlink" title="手写二分"></a>手写二分</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target == nums[m]:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">elif</span> target&gt;nums[m]:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>这个耗时还少，赢麻了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> nums.index(target)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;binary-search&quot;&gt;&lt;a href=&quot;#binary-search&quot; class=&quot;headerlink&quot; title=&quot;binary-search&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/binary-se</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>length-of-last-word</title>
    <link href="https://cyccyyycyc.github.io/2022/10/25/length-of-last-word/"/>
    <id>https://cyccyyycyc.github.io/2022/10/25/length-of-last-word/</id>
    <published>2022-10-25T11:20:18.000Z</published>
    <updated>2022-10-25T11:22:36.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="length-of-last-word"><a href="#length-of-last-word" class="headerlink" title="length-of-last-word"></a><a href="https://leetcode.cn/problems/length-of-last-word/">length-of-last-word</a></h1><p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。</p><p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><h2 id="反向遍历查找"><a href="#反向遍历查找" class="headerlink" title="反向遍历查找"></a>反向遍历查找</h2><p>反向找第一个字母，找到则记录tail word的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLastWord</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        tail = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i]!=<span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                <span class="keyword">while</span> i &gt; -<span class="number">1</span> <span class="keyword">and</span> s[i] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                    tail += <span class="number">1</span></span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> tail</span><br></pre></td></tr></table></figure><h2 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLastWord</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s.split()[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;length-of-last-word&quot;&gt;&lt;a href=&quot;#length-of-last-word&quot; class=&quot;headerlink&quot; title=&quot;length-of-last-word&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>binary-tree-inorder-traversal</title>
    <link href="https://cyccyyycyc.github.io/2022/10/25/binary-tree-inorder-traversal/"/>
    <id>https://cyccyyycyc.github.io/2022/10/25/binary-tree-inorder-traversal/</id>
    <published>2022-10-25T11:17:16.000Z</published>
    <updated>2022-10-25T11:19:37.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="binary-tree-inorder-traversal"><a href="#binary-tree-inorder-traversal" class="headerlink" title="binary-tree-inorder-traversal"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">binary-tree-inorder-traversal</a></h1><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p>函数里套函数，我愿理解为函数里的“全局”变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        trl = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">r</span>):</span><br><span class="line">            <span class="keyword">if</span> r:</span><br><span class="line">                inorder(r.left)</span><br><span class="line">                trl.append(r.val)</span><br><span class="line">                inorder(r.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> trl</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;binary-tree-inorder-traversal&quot;&gt;&lt;a href=&quot;#binary-tree-inorder-traversal&quot; class=&quot;headerlink&quot; title=&quot;binary-tree-inorder-traversal&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>symmetric-tree</title>
    <link href="https://cyccyyycyc.github.io/2022/10/25/symmetric-tree/"/>
    <id>https://cyccyyycyc.github.io/2022/10/25/symmetric-tree/</id>
    <published>2022-10-25T11:14:09.000Z</published>
    <updated>2022-10-25T11:16:32.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="symmetric-tree"><a href="#symmetric-tree" class="headerlink" title="symmetric-tree"></a><a href="https://leetcode.cn/problems/symmetric-tree/">symmetric-tree</a></h1><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 送入镜像结点</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">left, right</span>):</span><br><span class="line">            <span class="comment"># 左右结点为空</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">or</span> right):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 单边结点为空</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">and</span> right):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 左右结点不为空</span></span><br><span class="line">            <span class="comment"># 当值不等，返回0</span></span><br><span class="line">            <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 当值相等</span></span><br><span class="line">            <span class="comment"># 右结点的右子树和左结点的左子树比较</span></span><br><span class="line">            <span class="comment"># 右结点的左子树和左结点的右子树比较</span></span><br><span class="line">            <span class="keyword">return</span> dfs(left.left, right.right) <span class="keyword">and</span> dfs(left.right, right.left)</span><br><span class="line">        <span class="keyword">return</span> dfs(root.left, root.right)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;symmetric-tree&quot;&gt;&lt;a href=&quot;#symmetric-tree&quot; class=&quot;headerlink&quot; title=&quot;symmetric-tree&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/symmet</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>invert-binary-tree</title>
    <link href="https://cyccyyycyc.github.io/2022/10/25/invert-binary-tree/"/>
    <id>https://cyccyyycyc.github.io/2022/10/25/invert-binary-tree/</id>
    <published>2022-10-25T11:11:03.000Z</published>
    <updated>2022-10-25T11:13:33.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="invert-binary-tree"><a href="#invert-binary-tree" class="headerlink" title="invert-binary-tree"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">invert-binary-tree</a></h1><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="comment"># 三条语句顺序无影响</span></span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            self.invertTree(root.left)</span><br><span class="line">            self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;invert-binary-tree&quot;&gt;&lt;a href=&quot;#invert-binary-tree&quot; class=&quot;headerlink&quot; title=&quot;invert-binary-tree&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/pro</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>maximum-depth-of-binary-tree</title>
    <link href="https://cyccyyycyc.github.io/2022/10/24/maximum-depth-of-binary-tree/"/>
    <id>https://cyccyyycyc.github.io/2022/10/24/maximum-depth-of-binary-tree/</id>
    <published>2022-10-24T03:59:53.000Z</published>
    <updated>2022-10-24T04:30:42.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="maximum-depth-of-binary-tree"><a href="#maximum-depth-of-binary-tree" class="headerlink" title="maximum-depth-of-binary-tree"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">maximum-depth-of-binary-tree</a></h1><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><p>递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right))</span><br></pre></td></tr></table></figure><h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><p>模拟队列实现层次遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            q = collections.deque()</span><br><span class="line">            q.append(root)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(q):</span><br><span class="line">                depth += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                    tmp = q.popleft()</span><br><span class="line">                    <span class="keyword">if</span> tmp.left:</span><br><span class="line">                        q.append(tmp.left)</span><br><span class="line">                    <span class="keyword">if</span> tmp.right:</span><br><span class="line">                        q.append(tmp.right)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;maximum-depth-of-binary-tree&quot;&gt;&lt;a href=&quot;#maximum-depth-of-binary-tree&quot; class=&quot;headerlink&quot; title=&quot;maximum-depth-of-binary-tree&quot;&gt;&lt;/a&gt;&lt;a</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>linked-list-cycle</title>
    <link href="https://cyccyyycyc.github.io/2022/10/24/linked-list-cycle/"/>
    <id>https://cyccyyycyc.github.io/2022/10/24/linked-list-cycle/</id>
    <published>2022-10-24T03:43:30.000Z</published>
    <updated>2022-10-24T03:50:26.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linked-list-cycle"><a href="#linked-list-cycle" class="headerlink" title="linked-list-cycle"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">linked-list-cycle</a></h1><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>用一个集合来存储已经访问过的结点（不是val），遍历访问时，判断当前结点是否已经访问过。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            seen.add(head)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> head:</span><br><span class="line">            slow = fast = head</span><br><span class="line">            <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> slow == fast:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linked-list-cycle&quot;&gt;&lt;a href=&quot;#linked-list-cycle&quot; class=&quot;headerlink&quot; title=&quot;linked-list-cycle&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/proble</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>plus-one</title>
    <link href="https://cyccyyycyc.github.io/2022/10/24/plus-one/"/>
    <id>https://cyccyyycyc.github.io/2022/10/24/plus-one/</id>
    <published>2022-10-24T03:20:57.000Z</published>
    <updated>2022-10-24T03:26:38.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="plus-one"><a href="#plus-one" class="headerlink" title="plus-one"></a><a href="https://leetcode.cn/problems/plus-one/">plus-one</a></h1><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>从后往前找，9则置0，找到第一个不为9的+1返回。若全为9则在0位插入一个1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        l = <span class="built_in">len</span>(digits)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> digits[i] <span class="keyword">is</span> <span class="number">9</span>:</span><br><span class="line">                digits[i] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> i:</span><br><span class="line">                    digits.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digits[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;plus-one&quot;&gt;&lt;a href=&quot;#plus-one&quot; class=&quot;headerlink&quot; title=&quot;plus-one&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/plus-one/&quot;&gt;plus-one&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>merge-sorted-array</title>
    <link href="https://cyccyyycyc.github.io/2022/10/24/merge-sorted-array/"/>
    <id>https://cyccyyycyc.github.io/2022/10/24/merge-sorted-array/</id>
    <published>2022-10-24T02:43:07.000Z</published>
    <updated>2022-10-24T02:48:59.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="merge-sorted-array"><a href="#merge-sorted-array" class="headerlink" title="merge-sorted-array"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">merge-sorted-array</a></h1><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><p>哈哈哈哈哈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums1[m:] = nums2</span><br><span class="line">        nums1.sort()</span><br></pre></td></tr></table></figure><h2 id="倒序遍历"><a href="#倒序遍历" class="headerlink" title="倒序遍历"></a>倒序遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p1, p2, p3 = m-<span class="number">1</span>, n-<span class="number">1</span>, n+m-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1&gt;=<span class="number">0</span> <span class="keyword">and</span> p2&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] &gt; nums2[p2]):</span><br><span class="line">                nums1[p3] = nums1[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[p3] = nums2[p2]</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            p3 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p2&gt;=<span class="number">0</span> <span class="keyword">and</span> p3&gt;=<span class="number">0</span>:</span><br><span class="line">            nums1[p3] = nums2[p2]</span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">            p3 -= <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;merge-sorted-array&quot;&gt;&lt;a href=&quot;#merge-sorted-array&quot; class=&quot;headerlink&quot; title=&quot;merge-sorted-array&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/pro</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>implement-stack-using-queues</title>
    <link href="https://cyccyyycyc.github.io/2022/10/24/implement-stack-using-queues/"/>
    <id>https://cyccyyycyc.github.io/2022/10/24/implement-stack-using-queues/</id>
    <published>2022-10-24T02:07:25.000Z</published>
    <updated>2022-10-24T02:14:06.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="implement-stack-using-queues"><a href="#implement-stack-using-queues" class="headerlink" title="implement-stack-using-queues"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">implement-stack-using-queues</a></h1><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现 MyStack 类：</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//将元素 x 压入栈顶。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> <span class="comment">//移除并返回栈顶元素。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> <span class="comment">//返回栈顶元素。</span></span><br><span class="line">boolean <span class="title function_">empty</span><span class="params">()</span> <span class="comment">//如果栈是空的，返回 true ；否则，返回 false 。</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.st = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.st.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        tmp = self.st[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">del</span> self.st[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.st[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.st)==<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><h2 id="Dequeue-left"><a href="#Dequeue-left" class="headerlink" title="Dequeue-left"></a>Dequeue-left</h2><p>双端队列模拟，左边为栈顶</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.q = collections.deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.q.appendleft(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.q.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.q[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.q)==<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><h2 id="Dequeue-right"><a href="#Dequeue-right" class="headerlink" title="Dequeue-right"></a>Dequeue-right</h2><p>双端队列，右边为栈顶模拟</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.q = collections.deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.q.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.q.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.q[<span class="built_in">len</span>(self.q)-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.q)==<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;implement-stack-using-queues&quot;&gt;&lt;a href=&quot;#implement-stack-using-queues&quot; class=&quot;headerlink&quot; title=&quot;implement-stack-using-queues&quot;&gt;&lt;/a&gt;&lt;a</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>best-time-to-buy-and-sell-stock</title>
    <link href="https://cyccyyycyc.github.io/2022/10/23/best-time-to-buy-and-sell-stock/"/>
    <id>https://cyccyyycyc.github.io/2022/10/23/best-time-to-buy-and-sell-stock/</id>
    <published>2022-10-23T15:14:26.000Z</published>
    <updated>2022-10-23T15:32:15.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="best-time-to-buy-and-sell-stock"><a href="#best-time-to-buy-and-sell-stock" class="headerlink" title="best-time-to-buy-and-sell-stock"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">best-time-to-buy-and-sell-stock</a></h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>实际上就是找到一个 i&lt;j, max(prices[j] - prices[i])</p><h2 id="暴力穷举"><a href="#暴力穷举" class="headerlink" title="暴力穷举"></a>暴力穷举</h2><p>时间复杂度O(n^2)，超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(prices)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">                res = <span class="built_in">max</span>(prices[j]-prices[i], res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h2><p>思路：遍历一次，对于第i天记录此前价格最低点，假设在此前价格最低点买进，当天卖出，记录最大收益值。</p><p>时间复杂度O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices)==<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(prices)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        min_price = prices[<span class="number">0</span>]</span><br><span class="line">        max_income = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="comment"># 若今天卖出，获得最大收益是多少？是否是当前最大收益？</span></span><br><span class="line">            max_income = <span class="built_in">max</span>(max_income, price-min_price)</span><br><span class="line">            <span class="comment"># 更新当前价格最低点</span></span><br><span class="line">            min_price = <span class="built_in">min</span>(min_price, price)</span><br><span class="line">        <span class="keyword">return</span> max_income</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;best-time-to-buy-and-sell-stock&quot;&gt;&lt;a href=&quot;#best-time-to-buy-and-sell-stock&quot; class=&quot;headerlink&quot; title=&quot;best-time-to-buy-and-sell-stoc</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>climbing-stairs</title>
    <link href="https://cyccyyycyc.github.io/2022/10/23/climbing-stairs/"/>
    <id>https://cyccyyycyc.github.io/2022/10/23/climbing-stairs/</id>
    <published>2022-10-23T13:54:31.000Z</published>
    <updated>2022-10-23T14:16:46.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="climbing-stairs"><a href="#climbing-stairs" class="headerlink" title="climbing-stairs"></a><a href="https://leetcode.cn/problems/climbing-stairs/">climbing-stairs</a></h1><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>类似斐波那契数列</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>简单但超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.climbStairs(n-<span class="number">1</span>)+self.climbStairs(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>时间复杂度O(n)，空间复杂度O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">return</span> res[n]</span><br><span class="line">        <span class="comment"># 注意这里上限是n+1-1=n</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            res.append(res[-<span class="number">1</span>] + res[-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> res[n]</span><br></pre></td></tr></table></figure><h2 id="动态规划-优化空间"><a href="#动态规划-优化空间" class="headerlink" title="动态规划-优化空间"></a>动态规划-优化空间</h2><p>每次只用到n-1规模和n-2规模的解，所以可以只存前两个解。</p><p>时间复杂度O(n)，空间复杂度O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span> <span class="comment"># f(0)=1, f(1)=1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h2 id="记忆dfs"><a href="#记忆dfs" class="headerlink" title="记忆dfs"></a>记忆dfs</h2><p>记忆性dfs自顶向下计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, flag</span>):</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> i==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> flag[i]==<span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                flag[i] = dfs(i-<span class="number">1</span>, flag) + dfs(i-<span class="number">2</span>, flag)</span><br><span class="line">            <span class="keyword">return</span> flag[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(n, (n+<span class="number">1</span>)*[<span class="string">&#x27;?&#x27;</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;climbing-stairs&quot;&gt;&lt;a href=&quot;#climbing-stairs&quot; class=&quot;headerlink&quot; title=&quot;climbing-stairs&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/cli</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
