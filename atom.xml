<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cy</title>
  
  
  <link href="https://cyccyyycyc.github.io/atom.xml" rel="self"/>
  
  <link href="https://cyccyyycyc.github.io/"/>
  <updated>2022-10-24T04:30:42.969Z</updated>
  <id>https://cyccyyycyc.github.io/</id>
  
  <author>
    <name>Cy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>maximum-depth-of-binary-tree</title>
    <link href="https://cyccyyycyc.github.io/2022/10/24/maximum-depth-of-binary-tree/"/>
    <id>https://cyccyyycyc.github.io/2022/10/24/maximum-depth-of-binary-tree/</id>
    <published>2022-10-24T03:59:53.000Z</published>
    <updated>2022-10-24T04:30:42.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="maximum-depth-of-binary-tree"><a href="#maximum-depth-of-binary-tree" class="headerlink" title="maximum-depth-of-binary-tree"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">maximum-depth-of-binary-tree</a></h1><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><p>递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right))</span><br></pre></td></tr></table></figure><h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><p>模拟队列实现层次遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            q = collections.deque()</span><br><span class="line">            q.append(root)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(q):</span><br><span class="line">                depth += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                    tmp = q.popleft()</span><br><span class="line">                    <span class="keyword">if</span> tmp.left:</span><br><span class="line">                        q.append(tmp.left)</span><br><span class="line">                    <span class="keyword">if</span> tmp.right:</span><br><span class="line">                        q.append(tmp.right)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;maximum-depth-of-binary-tree&quot;&gt;&lt;a href=&quot;#maximum-depth-of-binary-tree&quot; class=&quot;headerlink&quot; title=&quot;maximum-depth-of-binary-tree&quot;&gt;&lt;/a&gt;&lt;a</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>linked-list-cycle</title>
    <link href="https://cyccyyycyc.github.io/2022/10/24/linked-list-cycle/"/>
    <id>https://cyccyyycyc.github.io/2022/10/24/linked-list-cycle/</id>
    <published>2022-10-24T03:43:30.000Z</published>
    <updated>2022-10-24T03:50:26.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linked-list-cycle"><a href="#linked-list-cycle" class="headerlink" title="linked-list-cycle"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">linked-list-cycle</a></h1><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>用一个集合来存储已经访问过的结点（不是val），遍历访问时，判断当前结点是否已经访问过。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            seen.add(head)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> head:</span><br><span class="line">            slow = fast = head</span><br><span class="line">            <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> slow == fast:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linked-list-cycle&quot;&gt;&lt;a href=&quot;#linked-list-cycle&quot; class=&quot;headerlink&quot; title=&quot;linked-list-cycle&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/proble</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>plus-one</title>
    <link href="https://cyccyyycyc.github.io/2022/10/24/plus-one/"/>
    <id>https://cyccyyycyc.github.io/2022/10/24/plus-one/</id>
    <published>2022-10-24T03:20:57.000Z</published>
    <updated>2022-10-24T03:26:38.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="plus-one"><a href="#plus-one" class="headerlink" title="plus-one"></a><a href="https://leetcode.cn/problems/plus-one/">plus-one</a></h1><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>从后往前找，9则置0，找到第一个不为9的+1返回。若全为9则在0位插入一个1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        l = <span class="built_in">len</span>(digits)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> digits[i] <span class="keyword">is</span> <span class="number">9</span>:</span><br><span class="line">                digits[i] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> i:</span><br><span class="line">                    digits.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digits[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;plus-one&quot;&gt;&lt;a href=&quot;#plus-one&quot; class=&quot;headerlink&quot; title=&quot;plus-one&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/plus-one/&quot;&gt;plus-one&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>merge-sorted-array</title>
    <link href="https://cyccyyycyc.github.io/2022/10/24/merge-sorted-array/"/>
    <id>https://cyccyyycyc.github.io/2022/10/24/merge-sorted-array/</id>
    <published>2022-10-24T02:43:07.000Z</published>
    <updated>2022-10-24T02:48:59.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="merge-sorted-array"><a href="#merge-sorted-array" class="headerlink" title="merge-sorted-array"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">merge-sorted-array</a></h1><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><p>哈哈哈哈哈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums1[m:] = nums2</span><br><span class="line">        nums1.sort()</span><br></pre></td></tr></table></figure><h2 id="倒序遍历"><a href="#倒序遍历" class="headerlink" title="倒序遍历"></a>倒序遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p1, p2, p3 = m-<span class="number">1</span>, n-<span class="number">1</span>, n+m-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1&gt;=<span class="number">0</span> <span class="keyword">and</span> p2&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] &gt; nums2[p2]):</span><br><span class="line">                nums1[p3] = nums1[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[p3] = nums2[p2]</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            p3 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p2&gt;=<span class="number">0</span> <span class="keyword">and</span> p3&gt;=<span class="number">0</span>:</span><br><span class="line">            nums1[p3] = nums2[p2]</span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">            p3 -= <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;merge-sorted-array&quot;&gt;&lt;a href=&quot;#merge-sorted-array&quot; class=&quot;headerlink&quot; title=&quot;merge-sorted-array&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/pro</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>implement-stack-using-queues</title>
    <link href="https://cyccyyycyc.github.io/2022/10/24/implement-stack-using-queues/"/>
    <id>https://cyccyyycyc.github.io/2022/10/24/implement-stack-using-queues/</id>
    <published>2022-10-24T02:07:25.000Z</published>
    <updated>2022-10-24T02:14:06.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="implement-stack-using-queues"><a href="#implement-stack-using-queues" class="headerlink" title="implement-stack-using-queues"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">implement-stack-using-queues</a></h1><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现 MyStack 类：</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//将元素 x 压入栈顶。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> <span class="comment">//移除并返回栈顶元素。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> <span class="comment">//返回栈顶元素。</span></span><br><span class="line">boolean <span class="title function_">empty</span><span class="params">()</span> <span class="comment">//如果栈是空的，返回 true ；否则，返回 false 。</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.st = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.st.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        tmp = self.st[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">del</span> self.st[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.st[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.st)==<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><h2 id="Dequeue-left"><a href="#Dequeue-left" class="headerlink" title="Dequeue-left"></a>Dequeue-left</h2><p>双端队列模拟，左边为栈顶</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.q = collections.deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.q.appendleft(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.q.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.q[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.q)==<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><h2 id="Dequeue-right"><a href="#Dequeue-right" class="headerlink" title="Dequeue-right"></a>Dequeue-right</h2><p>双端队列，右边为栈顶模拟</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.q = collections.deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.q.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.q.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.q[<span class="built_in">len</span>(self.q)-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.q)==<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;implement-stack-using-queues&quot;&gt;&lt;a href=&quot;#implement-stack-using-queues&quot; class=&quot;headerlink&quot; title=&quot;implement-stack-using-queues&quot;&gt;&lt;/a&gt;&lt;a</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>best-time-to-buy-and-sell-stock</title>
    <link href="https://cyccyyycyc.github.io/2022/10/23/best-time-to-buy-and-sell-stock/"/>
    <id>https://cyccyyycyc.github.io/2022/10/23/best-time-to-buy-and-sell-stock/</id>
    <published>2022-10-23T15:14:26.000Z</published>
    <updated>2022-10-23T15:32:15.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="best-time-to-buy-and-sell-stock"><a href="#best-time-to-buy-and-sell-stock" class="headerlink" title="best-time-to-buy-and-sell-stock"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">best-time-to-buy-and-sell-stock</a></h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>实际上就是找到一个 i&lt;j, max(prices[j] - prices[i])</p><h2 id="暴力穷举"><a href="#暴力穷举" class="headerlink" title="暴力穷举"></a>暴力穷举</h2><p>时间复杂度O(n^2)，超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(prices)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">                res = <span class="built_in">max</span>(prices[j]-prices[i], res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h2><p>思路：遍历一次，对于第i天记录此前价格最低点，假设在此前价格最低点买进，当天卖出，记录最大收益值。</p><p>时间复杂度O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices)==<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(prices)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        min_price = prices[<span class="number">0</span>]</span><br><span class="line">        max_income = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="comment"># 若今天卖出，获得最大收益是多少？是否是当前最大收益？</span></span><br><span class="line">            max_income = <span class="built_in">max</span>(max_income, price-min_price)</span><br><span class="line">            <span class="comment"># 更新当前价格最低点</span></span><br><span class="line">            min_price = <span class="built_in">min</span>(min_price, price)</span><br><span class="line">        <span class="keyword">return</span> max_income</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;best-time-to-buy-and-sell-stock&quot;&gt;&lt;a href=&quot;#best-time-to-buy-and-sell-stock&quot; class=&quot;headerlink&quot; title=&quot;best-time-to-buy-and-sell-stoc</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>climbing-stairs</title>
    <link href="https://cyccyyycyc.github.io/2022/10/23/climbing-stairs/"/>
    <id>https://cyccyyycyc.github.io/2022/10/23/climbing-stairs/</id>
    <published>2022-10-23T13:54:31.000Z</published>
    <updated>2022-10-23T14:16:46.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="climbing-stairs"><a href="#climbing-stairs" class="headerlink" title="climbing-stairs"></a><a href="https://leetcode.cn/problems/climbing-stairs/">climbing-stairs</a></h1><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>类似斐波那契数列</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>简单但超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.climbStairs(n-<span class="number">1</span>)+self.climbStairs(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>时间复杂度O(n)，空间复杂度O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">return</span> res[n]</span><br><span class="line">        <span class="comment"># 注意这里上限是n+1-1=n</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            res.append(res[-<span class="number">1</span>] + res[-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> res[n]</span><br></pre></td></tr></table></figure><h2 id="动态规划-优化空间"><a href="#动态规划-优化空间" class="headerlink" title="动态规划-优化空间"></a>动态规划-优化空间</h2><p>每次只用到n-1规模和n-2规模的解，所以可以只存前两个解。</p><p>时间复杂度O(n)，空间复杂度O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span> <span class="comment"># f(0)=1, f(1)=1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h2 id="记忆dfs"><a href="#记忆dfs" class="headerlink" title="记忆dfs"></a>记忆dfs</h2><p>记忆性dfs自顶向下计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, flag</span>):</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> i==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> flag[i]==<span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                flag[i] = dfs(i-<span class="number">1</span>, flag) + dfs(i-<span class="number">2</span>, flag)</span><br><span class="line">            <span class="keyword">return</span> flag[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(n, (n+<span class="number">1</span>)*[<span class="string">&#x27;?&#x27;</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;climbing-stairs&quot;&gt;&lt;a href=&quot;#climbing-stairs&quot; class=&quot;headerlink&quot; title=&quot;climbing-stairs&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/cli</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Hierarchical-Clustering</title>
    <link href="https://cyccyyycyc.github.io/2022/10/22/Hierarchical-Clustering/"/>
    <id>https://cyccyyycyc.github.io/2022/10/22/Hierarchical-Clustering/</id>
    <published>2022-10-22T11:10:17.000Z</published>
    <updated>2022-10-23T05:29:20.672Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="层次聚类-Hierarchical-Clustering"><a href="#层次聚类-Hierarchical-Clustering" class="headerlink" title="层次聚类 Hierarchical-Clustering"></a>层次聚类 Hierarchical-Clustering</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>随着网络技术的发展，我们迎来了信息爆炸的时代。我们都知道现代大数据有4个特点：</p><ol><li>体量大 Volume</li><li>高速化 Velocity</li><li>多样化 Variety</li><li>低价值密度 Value</li></ol><p>未经处理的数据信息之间的联系往往较低，体量大而价值密度低。为了更好地挖掘数据价值，一个思路是找到数据之间的相似点进行度量和聚类，将数据点进行聚类，获得关联以更好地利用数据。网络世界中的推荐算法就是数据应用的一个典型例子。如淘宝、京东、拼多多等购物平台的商品推荐页面，谷歌、百度等搜索引擎的推荐回答，网易云音乐的日推歌曲……高效的推荐算法可以帮助我们快速的从体量庞大的信息流中定位到我们需要的有价值的数据，一定程度上便利了我们的生活。</p><p>推荐算法如何能实现推荐我们感兴趣的内容呢？我们往往会发现这样一个事实：品味相似的人会对相似的事物感兴趣。由此衍生出的一个思路是从相似的人出发：如找到兴趣爱好相同的两个人A和B，便可以将A感兴趣的内容推荐给B，由此推广到整个社区类群。在实际应用中，有协同过滤算法基于用户历史数据对用户进行群组划分并在此基础上推荐相似的物品，挖掘用户潜在兴趣。</p><p>在协同过滤中实现聚类有较多方法，本实验选择自底向上的层次聚类进行复现。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>先明确我们要实现什么：我们有一些离散的无关联的数据点，想要衡量它们之间的相似度，并以此为准则进行聚类。</p><p>那么这就要解决2个问题：</p><ol><li>相似度如何定义？</li><li>如何评估聚类的效果？</li></ol><p>首先，关于相似度定义的问题，需要定义一个函数来进行样本距离的衡量。如：</p><ol><li>Single-Linkage最短距离法：取两个类中距离最近的两个样本的距离作为两个集合的距离。</li><li>Complete-Linkage最长距离法：取两个集合中距离最远的两个点的距离作为两个集合的距离。</li><li>Average-linkage中间距离法：取两两距离的平均值作为两个集合之间的距离。</li><li>类平均法：取两两距离的中值作为两个集合之间的距离。</li></ol><p>四种方法各有特点：</p><ol><li>最短距离法相对限制较少，最终会得到一个相对松散的社群。</li><li>最长距离法相对限制较大。一个问题是：有可能两个类群已经很接近了，但由于单个样本的干扰便没有合并。</li><li>最短距离和最长距离法这考虑了某个有特点的数据，而没有考虑类内数据的整体特点，时间复杂度相对较低。</li><li>类平均法与取均值相比更能消除个别偏离样本对结果的干扰。</li></ol><p>其次，关于聚类效果评估的问题。容易发现，聚类和分类是不同的。对于分类问题，我们已经有了正确的标签，因此分类问题是一个有监督的学习。而聚类本身没有一个“正确”的结果，是一种无监督的学习。因为聚类没有一个确定的答案，目前尚未有一个效果较好的的评测指标评价聚类效果，更多的是靠数据可视化和人工评测效果。</p><p>层次聚类有两种思路：</p><ol><li>自底向上的凝聚法：凝聚法指的是初始时将每个样本点当做一个类簇，然后依据相似度合并这些初始的类簇，直到达到某种条件或者达到设定的分类数目。</li><li>自顶向下的分裂法：初始时将所有的样本归为一个类簇，然后依据相似度进行逐渐的分裂，直到达到某种条件或者达到设定的分类数目。</li></ol><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>距离度量函数可以任意定义，较为灵活。</li><li>层次聚类结果是一个树状图，包含关系结构清晰，一个结点可以属于多个类。</li><li>一次性获得整个聚类树，可以直接根据需要对聚类树进行横向切割获得指定数量的类簇。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>计算复杂度大</li><li>贪心算法获得局部最优，不一定是全局最优解。</li><li>层次聚类具有不可逆性，一旦聚类结果形成，想要就不能重新合并来优化聚类性能。</li><li>对于不同的问题，需要人为选择合适的距离度量函数、终止条件和参数。</li></ol><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li>移除网络中的所有边，得到有 n 个孤立节点，每个节点作为一个集合。</li><li>两两计算相似度</li><li>根据选取相似度最小的两个结点进行合并</li><li>重复2和3直到满足条件终止，形成树状图</li><li>根据实际需求横切树状图，获得聚类的社区结构</li></ol><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python==3.8.8</span><br><span class="line">numpy==1.23.3</span><br><span class="line">scipy==1.7.0</span><br><span class="line">scikit-learn==1.1.2</span><br><span class="line">matplotlib==3.5.3</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.cluster <span class="keyword">import</span> hierarchy</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> AgglomerativeClustering</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入数据集</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">iris_data = iris.data</span><br><span class="line"><span class="built_in">print</span>(iris_data.shape, iris_data.dtype)</span><br><span class="line"><span class="comment"># output:(150, 4) float64</span></span><br></pre></td></tr></table></figure><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据集预处理</span></span><br><span class="line"></span><br><span class="line">data = np.array(iris_data[:, <span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(data.shape)</span><br><span class="line"><span class="comment"># output:(150, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据的每一个特征缩放到给定的范围(0,1)</span></span><br><span class="line">min_max_scaler = preprocessing.MinMaxScaler()</span><br><span class="line">data_M = min_max_scaler.fit_transform(data)</span><br></pre></td></tr></table></figure><h4 id="层次聚类树状图"><a href="#层次聚类树状图" class="headerlink" title="层次聚类树状图"></a>层次聚类树状图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">6</span>))</span><br><span class="line">plt.title(<span class="string">&quot;Dendrograms&quot;</span>)  </span><br><span class="line"><span class="comment">#  ward：集合间距离等于两类对象之间的最小距离。（即最短距离法single-linkage聚类）</span></span><br><span class="line"><span class="comment">#  计算距离的方法，可以是 “euclidean”（即 “l2”，欧氏距离）</span></span><br><span class="line">Z = hierarchy.linkage(data_scaled, method=<span class="string">&#x27;ward&#x27;</span>, metric=<span class="string">&#x27;euclidean&#x27;</span>)</span><br><span class="line">p = hierarchy.dendrogram(Z, <span class="number">0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2022/10/22/Hierarchical-Clustering/1.jpg" alt="1"></p><h4 id="层次聚类分布图"><a href="#层次聚类分布图" class="headerlink" title="层次聚类分布图"></a>层次聚类分布图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  ward：集合间距离等于两类对象之间的最小距离。（即最短距离法single-linkage聚类）</span></span><br><span class="line"><span class="comment">#  计算距离的方法，可以是 “euclidean”（即 “l2”，欧氏距离）</span></span><br><span class="line">ac = AgglomerativeClustering(n_clusters=<span class="number">6</span>, affinity=<span class="string">&#x27;euclidean&#x27;</span>, linkage=<span class="string">&#x27;ward&#x27;</span>)</span><br><span class="line">ac.fit(data_scaled)</span><br><span class="line">labels = ac.fit_predict(data_scaled)</span><br><span class="line">plt.scatter(data_scaled[:,<span class="number">0</span>], data_scaled[:,<span class="number">1</span>], c=labels)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2022/10/22/Hierarchical-Clustering/2.jpg" alt="2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;层次聚类-Hierarchical-Clustering&quot;&gt;&lt;a href=&quot;#层次聚类-Hierarchical-Clustering&quot; class=&quot;headerlink&quot; title=&quot;层次聚类 Hierarchical-Clust</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>move-zeros</title>
    <link href="https://cyccyyycyc.github.io/2022/10/22/move-zeros/"/>
    <id>https://cyccyyycyc.github.io/2022/10/22/move-zeros/</id>
    <published>2022-10-22T06:03:13.000Z</published>
    <updated>2022-10-23T13:55:43.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="move-zeros"><a href="#move-zeros" class="headerlink" title="move-zeros"></a><a href="https://leetcode.cn/problems/move-zeroes/">move-zeros</a></h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow = fast = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num != <span class="number">0</span>:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 尾部置零</span></span><br><span class="line">        <span class="keyword">while</span>(slow &lt; fast):</span><br><span class="line">            nums[slow] = <span class="number">0</span></span><br><span class="line">            slow += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="move-amp-append"><a href="#move-amp-append" class="headerlink" title="move &amp; append"></a>move &amp; append</h2><p>这个相对来说慢很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> <span class="keyword">in</span> nums:</span><br><span class="line">            nums.remove(<span class="number">0</span>)</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (cnt):</span><br><span class="line">            nums.append(<span class="number">0</span>)</span><br><span class="line">            cnt -= <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;move-zeros&quot;&gt;&lt;a href=&quot;#move-zeros&quot; class=&quot;headerlink&quot; title=&quot;move-zeros&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/move-zeroes/&quot;&gt;move</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>roman-to-integer</title>
    <link href="https://cyccyyycyc.github.io/2022/10/22/roman-to-integer/"/>
    <id>https://cyccyyycyc.github.io/2022/10/22/roman-to-integer/</id>
    <published>2022-10-22T03:26:12.000Z</published>
    <updated>2022-10-22T03:31:43.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="roman-to-integer"><a href="#roman-to-integer" class="headerlink" title="roman-to-integer"></a><a href="https://leetcode.cn/problems/roman-to-integer/">roman-to-integer</a></h1><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="built_in">dict</span> = &#123;<span class="string">&#x27;I&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;V&#x27;</span>:<span class="number">5</span>, <span class="string">&#x27;X&#x27;</span>:<span class="number">10</span>, <span class="string">&#x27;L&#x27;</span>:<span class="number">50</span>, <span class="string">&#x27;C&#x27;</span>:<span class="number">100</span>, <span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>, <span class="string">&#x27;M&#x27;</span>:<span class="number">1000</span>&#125;</span><br><span class="line">        st = [<span class="number">0</span>]</span><br><span class="line">        top = ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            st.append(<span class="built_in">dict</span>[i])</span><br><span class="line">            <span class="comment"># 小数在大数前面，则小数取负</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dict</span>[i]&gt;st[top]):</span><br><span class="line">                st[top] = - st[top]</span><br><span class="line">            top += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> st:</span><br><span class="line">            ans += i</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;roman-to-integer&quot;&gt;&lt;a href=&quot;#roman-to-integer&quot; class=&quot;headerlink&quot; title=&quot;roman-to-integer&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>longest-common-prefix</title>
    <link href="https://cyccyyycyc.github.io/2022/10/22/longest-common-prefix/"/>
    <id>https://cyccyyycyc.github.io/2022/10/22/longest-common-prefix/</id>
    <published>2022-10-22T02:45:49.000Z</published>
    <updated>2022-10-22T02:53:44.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="longest-common-prefix"><a href="#longest-common-prefix" class="headerlink" title="longest-common-prefix"></a><a href="https://leetcode.cn/problems/longest-common-prefix/">longest-common-prefix</a></h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>逐次遍历，两两找最长前缀。</p><p>注意每次拿前缀和新的字符串比较时，用切片保证前缀长度比新字符串小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        prefix = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> prefix</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prefix = strs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> str0 <span class="keyword">in</span> strs:</span><br><span class="line">            <span class="comment"># 前缀长度一定是最小的</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(str0) &lt; <span class="built_in">len</span>(prefix):</span><br><span class="line">                prefix = prefix[<span class="number">0</span>: <span class="built_in">len</span>(str0)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(<span class="built_in">len</span>(str0), <span class="built_in">len</span>(prefix))):</span><br><span class="line">                <span class="keyword">if</span> prefix[i]!= str0[i]:</span><br><span class="line">                    prefix = prefix[<span class="number">0</span>:i]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> prefix</span><br></pre></td></tr></table></figure><h2 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h2><p>用min和max获得字典排序的最小串和最大串，直接找两者最大前缀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        str0, str1 = <span class="built_in">min</span>(strs), <span class="built_in">max</span>(strs)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str0)):</span><br><span class="line">            <span class="keyword">if</span> str0[i]!=str1[i]:</span><br><span class="line">                <span class="keyword">return</span> str0[:i]</span><br><span class="line">        <span class="keyword">return</span> str0</span><br></pre></td></tr></table></figure><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>set函数生成集合，集合中不能有相同元素，可以用集合长度确定strs相同位置的元素是否相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonPrefix</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        prefix = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">zip</span>(*strs)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(i))==<span class="number">1</span>:</span><br><span class="line">                prefix += i[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> prefix</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;longest-common-prefix&quot;&gt;&lt;a href=&quot;#longest-common-prefix&quot; class=&quot;headerlink&quot; title=&quot;longest-common-prefix&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetco</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>merge-two-sorted-lists</title>
    <link href="https://cyccyyycyc.github.io/2022/10/21/merge-two-sorted-lists/"/>
    <id>https://cyccyyycyc.github.io/2022/10/21/merge-two-sorted-lists/</id>
    <published>2022-10-21T06:42:21.000Z</published>
    <updated>2022-10-21T06:47:46.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="merge-two-sorted-lists"><a href="#merge-two-sorted-lists" class="headerlink" title="merge-two-sorted-lists"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">merge-two-sorted-lists</a></h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &gt; list2.val:</span><br><span class="line">                list1, list2 = list2, list1</span><br><span class="line">            list1.<span class="built_in">next</span> = self.mergeTwoLists(list1.<span class="built_in">next</span>, list2)</span><br><span class="line">        <span class="keyword">return</span> list1 <span class="keyword">or</span> list2</span><br></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>用带头节点的单链表统一操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        tmp = cur = ListNode(-<span class="number">1</span>)  <span class="comment"># Head Node</span></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &gt; list2.val:</span><br><span class="line">                cur.<span class="built_in">next</span>, list2 = list2, list2.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span>, list1 = list1, list1.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line">        <span class="keyword">return</span> tmp.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;merge-two-sorted-lists&quot;&gt;&lt;a href=&quot;#merge-two-sorted-lists&quot; class=&quot;headerlink&quot; title=&quot;merge-two-sorted-lists&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://lee</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>search-insert-position</title>
    <link href="https://cyccyyycyc.github.io/2022/10/21/search-insert-position/"/>
    <id>https://cyccyyycyc.github.io/2022/10/21/search-insert-position/</id>
    <published>2022-10-21T06:11:51.000Z</published>
    <updated>2022-10-21T06:17:15.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="search-insert-position"><a href="#search-insert-position" class="headerlink" title="search-insert-position"></a><a href="https://leetcode.cn/problems/search-insert-position">search-insert-position</a></h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>时间复杂度O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span>(target &lt;= n):</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>时间复杂度为 O(log n) </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r):</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target):</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (nums[mid]&lt;target):</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;search-insert-position&quot;&gt;&lt;a href=&quot;#search-insert-position&quot; class=&quot;headerlink&quot; title=&quot;search-insert-position&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://lee</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>remove-element</title>
    <link href="https://cyccyyycyc.github.io/2022/10/20/remove-element/"/>
    <id>https://cyccyyycyc.github.io/2022/10/20/remove-element/</id>
    <published>2022-10-20T12:14:18.000Z</published>
    <updated>2022-10-21T03:50:13.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="remove-element"><a href="#remove-element" class="headerlink" title="remove-element"></a><a href="https://leetcode.cn/problems/remove-element/">remove-element</a></h1><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><h2 id="反向遍历POP"><a href="#反向遍历POP" class="headerlink" title="反向遍历POP"></a>反向遍历POP</h2><p>注意索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val):</span><br><span class="line">                nums.pop(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>记录val值个数，一次循环，元素前移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            nums[i-k] = nums[i]</span><br><span class="line">            <span class="keyword">if</span>(n==val):</span><br><span class="line">                k = k+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l-k</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>l为新数组索引，r为原数组索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span>(nums[r]!=val):</span><br><span class="line">                nums[l]=nums[r]</span><br><span class="line">                l = l+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure><h2 id="count-amp-remove"><a href="#count-amp-remove" class="headerlink" title="count &amp; remove"></a>count &amp; remove</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a = nums.count(val)  <span class="comment"># 计算数组nums中val值的个数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a):</span><br><span class="line">            nums.remove(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><h2 id="index-amp-del"><a href="#index-amp-del" class="headerlink" title="index &amp; del"></a>index &amp; del</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">while</span> val <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">del</span> nums[nums.index(val)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;remove-element&quot;&gt;&lt;a href=&quot;#remove-element&quot; class=&quot;headerlink&quot; title=&quot;remove-element&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>remove-duplicates-from-sorted-array</title>
    <link href="https://cyccyyycyc.github.io/2022/10/20/remove-duplicates-from-sorted-array/"/>
    <id>https://cyccyyycyc.github.io/2022/10/20/remove-duplicates-from-sorted-array/</id>
    <published>2022-10-20T12:10:30.000Z</published>
    <updated>2022-10-21T03:50:06.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="remove-duplicates-from-sorted-array"><a href="#remove-duplicates-from-sorted-array" class="headerlink" title="remove-duplicates-from-sorted-array"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array">remove-duplicates-from-sorted-array</a></h1><p>删除有序数组中的重复项</p><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><h2 id="1-倒序POP"><a href="#1-倒序POP" class="headerlink" title="1 倒序POP"></a>1 倒序POP</h2><p>注意索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i-<span class="number">1</span>]):</span><br><span class="line">                nums.pop(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><h2 id="2-快慢指针"><a href="#2-快慢指针" class="headerlink" title="2 快慢指针"></a>2 快慢指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        fast = <span class="number">1</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != nums[slow]):</span><br><span class="line">                slow = slow + <span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">            fast = fast + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;remove-duplicates-from-sorted-array&quot;&gt;&lt;a href=&quot;#remove-duplicates-from-sorted-array&quot; class=&quot;headerlink&quot; title=&quot;remove-duplicates-from</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>palindrome-number</title>
    <link href="https://cyccyyycyc.github.io/2022/10/20/palindrome-number/"/>
    <id>https://cyccyyycyc.github.io/2022/10/20/palindrome-number/</id>
    <published>2022-10-20T12:00:38.000Z</published>
    <updated>2022-10-21T03:49:58.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="palindrome-number"><a href="#palindrome-number" class="headerlink" title="palindrome-number"></a><a href="https://leetcode.cn/problems/palindrome-number/">palindrome-number</a></h1><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>例如，121 是回文，而 123 不是。</p><h2 id="直接计算"><a href="#直接计算" class="headerlink" title="直接计算"></a>直接计算</h2><p>如果x小于0则必不是回文数<br>如果x大于0则计算其倒序数值，比较和原x是否相等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> x&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = <span class="number">0</span></span><br><span class="line">            num = x</span><br><span class="line">            <span class="keyword">while</span>(num&gt;<span class="number">0</span>):</span><br><span class="line">                cur = cur*<span class="number">10</span> + num%<span class="number">10</span></span><br><span class="line">                num = num//<span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> cur == x      </span><br></pre></td></tr></table></figure><h2 id="反向切片"><a href="#反向切片" class="headerlink" title="反向切片"></a>反向切片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(x) == <span class="built_in">str</span>(x)[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;palindrome-number&quot;&gt;&lt;a href=&quot;#palindrome-number&quot; class=&quot;headerlink&quot; title=&quot;palindrome-number&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/proble</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>valid-parentheses</title>
    <link href="https://cyccyyycyc.github.io/2022/10/20/valid-parentheses/"/>
    <id>https://cyccyyycyc.github.io/2022/10/20/valid-parentheses/</id>
    <published>2022-10-20T11:55:38.000Z</published>
    <updated>2022-10-21T03:50:41.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="valid-parentheses"><a href="#valid-parentheses" class="headerlink" title="valid-parentheses"></a><a href="https://leetcode.cn/problems/valid-parentheses/description/">valid-parentheses</a></h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>利用字典构造匹配关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="built_in">dict</span> = &#123;<span class="string">&#x27;(&#x27;</span>:<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>:<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;[&#x27;</span>:<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;?&#x27;</span>:<span class="string">&#x27;?&#x27;</span>&#125;</span><br><span class="line">        stack = [<span class="string">&#x27;?&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="built_in">dict</span>:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">dict</span>[stack.pop()] != c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack)==<span class="number">1</span></span><br><span class="line">                       </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;valid-parentheses&quot;&gt;&lt;a href=&quot;#valid-parentheses&quot; class=&quot;headerlink&quot; title=&quot;valid-parentheses&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/proble</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>reverse-linked-list</title>
    <link href="https://cyccyyycyc.github.io/2022/10/20/reverse-linked-list/"/>
    <id>https://cyccyyycyc.github.io/2022/10/20/reverse-linked-list/</id>
    <published>2022-10-20T11:26:17.000Z</published>
    <updated>2022-10-21T03:50:19.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="reverse-linked-list"><a href="#reverse-linked-list" class="headerlink" title="reverse-linked-list"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">reverse-linked-list</a></h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        ans = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            p = head.<span class="built_in">next</span></span><br><span class="line">            head.<span class="built_in">next</span> = ans</span><br><span class="line">            ans = head</span><br><span class="line">            head = p</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        last = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;reverse-linked-list&quot;&gt;&lt;a href=&quot;#reverse-linked-list&quot; class=&quot;headerlink&quot; title=&quot;reverse-linked-list&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>two-sum</title>
    <link href="https://cyccyyycyc.github.io/2022/10/20/two-sum/"/>
    <id>https://cyccyyycyc.github.io/2022/10/20/two-sum/</id>
    <published>2022-10-20T11:02:12.000Z</published>
    <updated>2022-10-21T03:50:34.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="two-sum"><a href="#two-sum" class="headerlink" title="two-sum"></a><a href="https://leetcode.cn/problems/two-sum/">two-sum</a></h1><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>例如：</p><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>空间复杂度O(n)<br>时间复杂度O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            x = target - n</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> <span class="built_in">dict</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="built_in">dict</span>[x], i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">dict</span>[n] = i</span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>两层循环，时间复杂度O(n^2)<br>注意：不能考虑重复元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, l, <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;two-sum&quot;&gt;&lt;a href=&quot;#two-sum&quot; class=&quot;headerlink&quot; title=&quot;two-sum&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/two-sum/&quot;&gt;two-sum&lt;/a&gt;&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>The Transfer-based Black-box Attack Method by 韦星星</title>
    <link href="https://cyccyyycyc.github.io/2022/10/19/The-Transfer-based-Black-box-Attack-Method-by%E9%9F%A6%E6%98%9F%E6%98%9F/"/>
    <id>https://cyccyyycyc.github.io/2022/10/19/The-Transfer-based-Black-box-Attack-Method-by%E9%9F%A6%E6%98%9F%E6%98%9F/</id>
    <published>2022-10-19T15:57:49.000Z</published>
    <updated>2022-10-21T03:50:27.089Z</updated>
    
    <content type="html"><![CDATA[<p>观后感</p><p><a href="http://scl.sribd.cn/seminar/index.html">Source</a> The 4th Lecture</p><h2 id="基于Spatial-Momentum的迁移性增强方法"><a href="#基于Spatial-Momentum的迁移性增强方法" class="headerlink" title="基于Spatial Momentum的迁移性增强方法"></a>基于Spatial Momentum的迁移性增强方法</h2><h3 id="FGSM-Fast-Gradient-Sign-Method"><a href="#FGSM-Fast-Gradient-Sign-Method" class="headerlink" title="FGSM : Fast Gradient Sign Method"></a>FGSM : Fast Gradient Sign Method</h3><p>白盒场景下，用符号获得梯度方向，在原图增加噪声（对抗扰动）来生成对抗样本，是一种单步迭代攻击。</p><h3 id="I-FGSM-Iterative-Fast-Gradient-Sign-Method"><a href="#I-FGSM-Iterative-Fast-Gradient-Sign-Method" class="headerlink" title="I-FGSM : Iterative Fast Gradient Sign Method"></a>I-FGSM : Iterative Fast Gradient Sign Method</h3><p>多步迭代攻击，拟合效果更好了，但是迁移性不太好（可以从overfit角度直观理解）</p><h4 id="时序累加角度：时间域变换"><a href="#时序累加角度：时间域变换" class="headerlink" title="时序累加角度：时间域变换"></a>时序累加角度：时间域变换</h4><h5 id="MI-FGSM"><a href="#MI-FGSM" class="headerlink" title="MI-FGSM"></a>MI-FGSM</h5><p>时序上的梯度累加：当前梯度+过去梯度</p><h5 id="NI-FGSM"><a href="#NI-FGSM" class="headerlink" title="NI-FGSM"></a>NI-FGSM</h5><h4 id="数据增广角度：空间域变换"><a href="#数据增广角度：空间域变换" class="headerlink" title="数据增广角度：空间域变换"></a>数据增广角度：空间域变换</h4><h5 id="DII-FGSM-Diverse-Inputs"><a href="#DII-FGSM-Diverse-Inputs" class="headerlink" title="DII-FGSM : Diverse Inputs"></a>DII-FGSM : Diverse Inputs</h5><p>从数据增强角度，对输入数据有概率p进行随机大小的resize</p><h5 id="TI-FGSM-Translation-invariant-FGSM"><a href="#TI-FGSM-Translation-invariant-FGSM" class="headerlink" title="TI-FGSM : Translation invariant - FGSM"></a>TI-FGSM : Translation invariant - FGSM</h5><p>从数据增强角度，考虑像素点的领域（高斯）来生成对抗样本。</p><h4 id="时空累加角度"><a href="#时空累加角度" class="headerlink" title="时空累加角度"></a>时空累加角度</h4><h5 id="R-DIMI-FGSM"><a href="#R-DIMI-FGSM" class="headerlink" title="R-DIMI-FGSM"></a>R-DIMI-FGSM</h5><p>考虑梯度在空间上的累加，比较范围更广</p><h2 id="图像检测对抗样本的生成"><a href="#图像检测对抗样本的生成" class="headerlink" title="图像检测对抗样本的生成"></a>图像检测对抗样本的生成</h2><h3 id="现有方法问题"><a href="#现有方法问题" class="headerlink" title="现有方法问题"></a>现有方法问题</h3><p>现有攻击方法常常针对Fast-rcnn，攻击模型中的的分类模块（常常表征高级特征），而有些图像检测模型如yolo模型中无分类模块，则导致迁移性差。</p><ol><li>迁移性差，在一个模型训练生成的对抗样本往往无法成功攻击另一个模型。</li><li>时间复杂度高</li></ol><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><h4 id="改进描述"><a href="#改进描述" class="headerlink" title="改进描述"></a>改进描述</h4><p>一种想法是对抗样本迁移和模型之间的共性相关。要想增强迁移能力，则应该从模型间的共性切入。</p><p>传统方法是攻击Fast-rcnn模型中的分类模块，而有些模型中不存在分类模块，则分类模块显然不是模型的共同子架构。</p><p>因此，提出基于base network的对抗样本生成，取Fast-rcnn模型中一些普遍应用的架构（如VGG、ResNet一些经典架构…），用attention机制来定位特征层的目标机制，增加feature loss，从中间特征层入手破坏物体特征层的特征（原来是直接攻击模型更后面更高级的分类模块），获得更高的迁移性。</p><h4 id="Q1-：底层特征更共性？"><a href="#Q1-：底层特征更共性？" class="headerlink" title="Q1 ：底层特征更共性？"></a>Q1 ：底层特征更共性？</h4><p>这时候可能有人会提出一个问题，既然攻击迁移性往往和模型之间的共同点高度相关，那为什么不选取破坏更加具有共性的底层特征来获得更大的迁移性呢？回答是这样对图片的破坏较大，会导致对抗样本和原图的距离较远，选择在中间特征层攻击是对图片质量（和原图的相似度）和迁移性的权衡结果。</p><p>进一步解释，神经网络往往是一个放大的过程，在底层添加微小噪声，经过网络不断放大，最终和原图便相去甚远。</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="Q1：可以从什么角度切入提高迁移性"><a href="#Q1：可以从什么角度切入提高迁移性" class="headerlink" title="Q1：可以从什么角度切入提高迁移性?"></a>Q1：可以从什么角度切入提高迁移性?</h3><ol><li>从梯度出发，找到一个更泛化的梯度计算的方法</li><li>从模型架构共性出发。现在的模型架构趋于模块化，更容易找到共性，提高迁移性。</li><li>（笔者目前个人认为）从模型拟合数据分布的角度出发。不同模型学到的知识不同，有的模型注重纹理有的注重轮廓。</li></ol><h3 id="Q2-：无法被迁移攻击的模型？"><a href="#Q2-：无法被迁移攻击的模型？" class="headerlink" title="Q2 ：无法被迁移攻击的模型？"></a>Q2 ：无法被迁移攻击的模型？</h3><ol><li>从模型架构共性出发：黑盒场景下，如果一个模型无法被迁移攻击，那么说明本地模型和目标模型相似度极低。这不太符合现实应用。不过脉冲神经网络或许是一个角度。</li><li>从模型拟合数据分布角度出发：往往经过对抗训练的模型会具有更高的鲁棒性，相同架构下往往会更难以被对抗攻击，这表明模型拟合出了一个不一样的分布，这个分布含有更多的知识。（有点像“吃一堑长一智”，模型之前见识过了对抗攻击，便学会了如何应对）</li></ol><h3 id="Q3-：语义角度的迁移攻击？"><a href="#Q3-：语义角度的迁移攻击？" class="headerlink" title="Q3 ：语义角度的迁移攻击？"></a>Q3 ：语义角度的迁移攻击？</h3><p>现有方法往往修改图像亮度、锐度、饱和度等属性（对抗属性）来生成对抗样本。可以进行扩展，尝试修改一些视觉友好的语义属性（比如颜色）来生成对抗样本，思考并探索：哪种属性更易于迁移？</p><h3 id="Q4-：如何寻找共性？"><a href="#Q4-：如何寻找共性？" class="headerlink" title="Q4 ：如何寻找共性？"></a>Q4 ：如何寻找共性？</h3><ol><li>从data的特征空间变换角度，可以寻找不同模型之间的一致性</li><li>从降维解构角度，可以实现降低搜索维度，在低维空间中搜索降低时间复杂度，在高维空间中攻击获得好的攻击效果。</li></ol><h3 id="Q5-：迁移性的理论相关？"><a href="#Q5-：迁移性的理论相关？" class="headerlink" title="Q5 ：迁移性的理论相关？"></a>Q5 ：迁移性的理论相关？</h3><p>目前理论尚待完善。</p><p>关于可迁移性的度量，由于迁移并不独立存在，一定是从一个模型到另一个模型，所以目前也无统一度量方法。</p><h3 id="Q6-：可证明的迁移攻击的防御"><a href="#Q6-：可证明的迁移攻击的防御" class="headerlink" title="Q6 ：可证明的迁移攻击的防御"></a>Q6 ：可证明的迁移攻击的防御</h3><p>由于目前迁移攻击的发展空间巨大（效果很差成功率很低），所以没有相关的防御。一般经过对抗训练就能很好地防御了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;观后感&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://scl.sribd.cn/seminar/index.html&quot;&gt;Source&lt;/a&gt; The 4th Lecture&lt;/p&gt;
&lt;h2 id=&quot;基于Spatial-Momentum的迁移性增强方法&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="AISP" scheme="https://cyccyyycyc.github.io/categories/AISP/"/>
    
    
    <category term="对抗样本" scheme="https://cyccyyycyc.github.io/tags/%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC/"/>
    
  </entry>
  
</feed>
