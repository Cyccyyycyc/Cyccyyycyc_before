<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cy</title>
  
  
  <link href="https://cyccyyycyc.github.io/atom.xml" rel="self"/>
  
  <link href="https://cyccyyycyc.github.io/"/>
  <updated>2022-10-26T02:30:51.891Z</updated>
  <id>https://cyccyyycyc.github.io/</id>
  
  <author>
    <name>Cy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>intersection-of-two-linked-lists</title>
    <link href="https://cyccyyycyc.github.io/2022/10/26/intersection-of-two-linked-lists/"/>
    <id>https://cyccyyycyc.github.io/2022/10/26/intersection-of-two-linked-lists/</id>
    <published>2022-10-26T02:22:35.000Z</published>
    <updated>2022-10-26T02:30:51.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="intersection-of-two-linked-lists"><a class="markdownIt-Anchor" href="#intersection-of-two-linked-lists"></a> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">intersection-of-two-linked-lists</a></h1><p>相交链表</p><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><h2 id="哈希字典"><a class="markdownIt-Anchor" href="#哈希字典"></a> 哈希字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dic = <span class="built_in">set</span>()</span><br><span class="line">        p = headA</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            dic.add(p)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        p = headB</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h2 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h2><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mi>b</mi><mo>+</mo><mo stretchy="false">(</mo><mi>a</mi><mo>−</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>−</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a+(b-c)=b+(a-c)=a+b-c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">c</span></span></span></span></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        p, q = headA, headB</span><br><span class="line">        <span class="keyword">while</span> q != p:</span><br><span class="line">            p = p.<span class="built_in">next</span> <span class="keyword">if</span> p <span class="keyword">else</span> headB</span><br><span class="line">            q = q.<span class="built_in">next</span> <span class="keyword">if</span> q <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure><h2 id="去尾"><a class="markdownIt-Anchor" href="#去尾"></a> 去尾</h2><p>对两个链表，裁剪最大相同长度的尾部，同时遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        p, q = headA, headB</span><br><span class="line">        la, lb = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 计算链表A长度</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            la += <span class="number">1</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 计算链表B长度</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            lb +=<span class="number">1</span></span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 裁剪去头</span></span><br><span class="line">        <span class="keyword">while</span> la &gt; lb:</span><br><span class="line">            headA = headA.<span class="built_in">next</span></span><br><span class="line">            la -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lb &gt; la:</span><br><span class="line">            headB = headB.<span class="built_in">next</span></span><br><span class="line">            lb -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 此时la==lb</span></span><br><span class="line">        p, q = headA, headB</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> q:</span><br><span class="line">            <span class="keyword">if</span> p==q:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;intersection-of-two-linked-lists&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#intersection-of-two-linked-lists&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetco</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>minimum-depth-of-binary-tree</title>
    <link href="https://cyccyyycyc.github.io/2022/10/26/minimum-depth-of-binary-tree/"/>
    <id>https://cyccyyycyc.github.io/2022/10/26/minimum-depth-of-binary-tree/</id>
    <published>2022-10-26T02:13:14.000Z</published>
    <updated>2022-10-26T02:21:01.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="minimum-depth-of-binary-tree"><a class="markdownIt-Anchor" href="#minimum-depth-of-binary-tree"></a> <a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">minimum-depth-of-binary-tree</a></h1><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到<strong>最近叶子节点</strong>的最短路径上的节点数量。</p><p>**说明：**叶子节点是指没有子节点的节点。</p><h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.right <span class="keyword">and</span> root.left:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(self.minDepth(root.left), self.minDepth(root.right)) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> self.minDepth(root.right) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                <span class="keyword">return</span> self.minDepth(root.left) + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 遇到叶子结点则返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            q = [root]</span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                depth += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                    tmp = q[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">del</span> q[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">if</span> tmp.left:</span><br><span class="line">                        q.append(tmp.left)</span><br><span class="line">                    <span class="keyword">if</span> tmp.right:</span><br><span class="line">                        q.append(tmp.right)</span><br><span class="line">                    <span class="comment"># 遇到叶子结点则返回深度</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> tmp.right <span class="keyword">and</span> <span class="keyword">not</span> tmp.left:</span><br><span class="line">                        <span class="keyword">return</span> depth</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;minimum-depth-of-binary-tree&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#minimum-depth-of-binary-tree&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/pr</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</title>
    <link href="https://cyccyyycyc.github.io/2022/10/26/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/"/>
    <id>https://cyccyyycyc.github.io/2022/10/26/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</id>
    <published>2022-10-26T02:08:08.000Z</published>
    <updated>2022-10-26T02:11:06.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof"><a class="markdownIt-Anchor" href="#lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof"></a> <a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a></h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><h2 id="快慢指针"><a class="markdownIt-Anchor" href="#快慢指针"></a> 快慢指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthFromEnd</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>majority-element</title>
    <link href="https://cyccyyycyc.github.io/2022/10/26/majority-element/"/>
    <id>https://cyccyyycyc.github.io/2022/10/26/majority-element/</id>
    <published>2022-10-26T01:37:48.000Z</published>
    <updated>2022-10-26T02:06:54.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="majority-element"><a class="markdownIt-Anchor" href="#majority-element"></a> <a href="https://leetcode.cn/problems/majority-element/">majority-element</a></h1><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><h2 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h2><p>排序后取nums[n//2]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="字典"><a class="markdownIt-Anchor" href="#字典"></a> 字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">       <span class="keyword">return</span> Counter(nums).most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">       counts = collections.Counter(nums)</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">max</span>(counts.keys(), key=counts.get)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">set</span>(nums), key=nums.count)</span><br></pre></td></tr></table></figure><h2 id="摩尔投票"><a class="markdownIt-Anchor" href="#摩尔投票"></a> 摩尔投票</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        candidate = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 票数为0换候选人</span></span><br><span class="line">            <span class="keyword">if</span> count==<span class="number">0</span>:</span><br><span class="line">                candidate = num</span><br><span class="line">            count += (<span class="number">1</span> <span class="keyword">if</span> candidate == num <span class="keyword">else</span> -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure><h1 id="majority-element-ii"><a class="markdownIt-Anchor" href="#majority-element-ii"></a> <a href="https://leetcode.cn/problems/majority-element-ii/">majority-element-ii</a></h1><p>给定一个大小为 <em>n</em> 的整数数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。</p><h2 id="摩尔投票-2"><a class="markdownIt-Anchor" href="#摩尔投票-2"></a> 摩尔投票</h2><p>选出2个有希望超过⌊ n/3 ⌋的候选人，统计他们的票数是否真的超过⌊ n/3 ⌋。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        vote1 = <span class="number">0</span></span><br><span class="line">        vote2 = <span class="number">0</span></span><br><span class="line">        candidate1 = <span class="literal">None</span></span><br><span class="line">        candidate2 = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num==candidate1:</span><br><span class="line">                vote1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num==candidate2:</span><br><span class="line">                vote2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> vote1==<span class="number">0</span>:</span><br><span class="line">                vote1 = <span class="number">1</span></span><br><span class="line">                candidate1 = num</span><br><span class="line">            <span class="keyword">elif</span> vote2==<span class="number">0</span>:</span><br><span class="line">                vote2 = <span class="number">1</span></span><br><span class="line">                candidate2 = num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vote1 -= <span class="number">1</span></span><br><span class="line">                vote2 -= <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        cnt1, cnt2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> vote1&gt;<span class="number">0</span> <span class="keyword">and</span> num==candidate1:</span><br><span class="line">                cnt1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> vote2&gt;<span class="number">0</span> <span class="keyword">and</span> num==candidate2:</span><br><span class="line">                cnt2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt1 &gt; <span class="built_in">len</span>(nums)//<span class="number">3</span>:</span><br><span class="line">            res.append(candidate1)</span><br><span class="line">        <span class="keyword">if</span> cnt2 &gt; <span class="built_in">len</span>(nums)//<span class="number">3</span>:</span><br><span class="line">            res.append(candidate2)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="哈希字典"><a class="markdownIt-Anchor" href="#哈希字典"></a> 哈希字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> dic:</span><br><span class="line">                dic[num] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dic.keys():</span><br><span class="line">            <span class="keyword">if</span> dic[i] &gt; <span class="built_in">len</span>(nums)//<span class="number">3</span> :</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;majority-element&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#majority-element&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/majority-element/</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>single-number</title>
    <link href="https://cyccyyycyc.github.io/2022/10/26/single-number/"/>
    <id>https://cyccyyycyc.github.io/2022/10/26/single-number/</id>
    <published>2022-10-26T01:32:48.000Z</published>
    <updated>2022-10-26T01:37:16.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="single-number"><a class="markdownIt-Anchor" href="#single-number"></a> <a href="https://leetcode.cn/problems/single-number/">single-number</a></h1><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><h2 id="异或"><a class="markdownIt-Anchor" href="#异或"></a> 异或</h2><ol><li>任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。</li><li>任何数和其自身做异或运算，结果是 0，即a⊕a=0。</li><li>异或运算满足交换律。</li></ol><p>因此，把所有数值做异或运算即可得到结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            ans = ans ^ nums[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;single-number&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#single-number&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/single-number/&quot;&gt;single-</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>shu-zu-zhong-zhong-fu-de-shu-zi-lcof</title>
    <link href="https://cyccyyycyc.github.io/2022/10/26/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/"/>
    <id>https://cyccyyycyc.github.io/2022/10/26/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</id>
    <published>2022-10-26T01:25:40.000Z</published>
    <updated>2022-10-26T01:31:59.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shu-zu-zhong-zhong-fu-de-shu-zi-lcof"><a class="markdownIt-Anchor" href="#shu-zu-zhong-zhong-fu-de-shu-zi-lcof"></a> <a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">shu-zu-zhong-zhong-fu-de-shu-zi-lcof</a></h1><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><h2 id="哈希字典"><a class="markdownIt-Anchor" href="#哈希字典"></a> 哈希字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRepeatNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic = <span class="built_in">set</span>() </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums), <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic.add(nums[i])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="原地交换"><a class="markdownIt-Anchor" href="#原地交换"></a> 原地交换</h2><p>数组长度为n，数字范围在[0, n-1]，且有数字重复。所以可以调整索引数值一一对应，当发生冲突则返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRepeatNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i:</span><br><span class="line">                <span class="keyword">if</span> nums[nums[i]] == nums[i]:</span><br><span class="line">                    <span class="keyword">return</span> nums[i]</span><br><span class="line">                nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;shu-zu-zhong-zhong-fu-de-shu-zi-lcof&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#shu-zu-zhong-zhong-fu-de-shu-zi-lcof&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https:</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>binary-search</title>
    <link href="https://cyccyyycyc.github.io/2022/10/25/binary-search/"/>
    <id>https://cyccyyycyc.github.io/2022/10/25/binary-search/</id>
    <published>2022-10-25T11:23:44.000Z</published>
    <updated>2022-10-25T11:27:27.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="binary-search"><a class="markdownIt-Anchor" href="#binary-search"></a> <a href="https://leetcode.cn/problems/binary-search/">binary-search</a></h1><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><h2 id="手写二分"><a class="markdownIt-Anchor" href="#手写二分"></a> 手写二分</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target == nums[m]:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">elif</span> target&gt;nums[m]:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="调用函数"><a class="markdownIt-Anchor" href="#调用函数"></a> 调用函数</h2><p>这个耗时还少，赢麻了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> nums.index(target)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;binary-search&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#binary-search&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/binary-search/&quot;&gt;binary-</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>length-of-last-word</title>
    <link href="https://cyccyyycyc.github.io/2022/10/25/length-of-last-word/"/>
    <id>https://cyccyyycyc.github.io/2022/10/25/length-of-last-word/</id>
    <published>2022-10-25T11:20:18.000Z</published>
    <updated>2022-10-25T11:22:36.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="length-of-last-word"><a class="markdownIt-Anchor" href="#length-of-last-word"></a> <a href="https://leetcode.cn/problems/length-of-last-word/">length-of-last-word</a></h1><p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。</p><p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><h2 id="反向遍历查找"><a class="markdownIt-Anchor" href="#反向遍历查找"></a> 反向遍历查找</h2><p>反向找第一个字母，找到则记录tail word的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLastWord</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        tail = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i]!=<span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                <span class="keyword">while</span> i &gt; -<span class="number">1</span> <span class="keyword">and</span> s[i] != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                    tail += <span class="number">1</span></span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> tail</span><br></pre></td></tr></table></figure><h2 id="split"><a class="markdownIt-Anchor" href="#split"></a> split()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLastWord</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s.split()[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;length-of-last-word&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#length-of-last-word&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/length-of-l</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>binary-tree-inorder-traversal</title>
    <link href="https://cyccyyycyc.github.io/2022/10/25/binary-tree-inorder-traversal/"/>
    <id>https://cyccyyycyc.github.io/2022/10/25/binary-tree-inorder-traversal/</id>
    <published>2022-10-25T11:17:16.000Z</published>
    <updated>2022-10-25T11:19:37.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="binary-tree-inorder-traversal"><a class="markdownIt-Anchor" href="#binary-tree-inorder-traversal"></a> <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">binary-tree-inorder-traversal</a></h1><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p>函数里套函数，我愿理解为函数里的“全局”变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        trl = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">r</span>):</span><br><span class="line">            <span class="keyword">if</span> r:</span><br><span class="line">                inorder(r.left)</span><br><span class="line">                trl.append(r.val)</span><br><span class="line">                inorder(r.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> trl</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;binary-tree-inorder-traversal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#binary-tree-inorder-traversal&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>symmetric-tree</title>
    <link href="https://cyccyyycyc.github.io/2022/10/25/symmetric-tree/"/>
    <id>https://cyccyyycyc.github.io/2022/10/25/symmetric-tree/</id>
    <published>2022-10-25T11:14:09.000Z</published>
    <updated>2022-10-25T11:16:32.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="symmetric-tree"><a class="markdownIt-Anchor" href="#symmetric-tree"></a> <a href="https://leetcode.cn/problems/symmetric-tree/">symmetric-tree</a></h1><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 送入镜像结点</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">left, right</span>):</span><br><span class="line">            <span class="comment"># 左右结点为空</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">or</span> right):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 单边结点为空</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">and</span> right):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 左右结点不为空</span></span><br><span class="line">            <span class="comment"># 当值不等，返回0</span></span><br><span class="line">            <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 当值相等</span></span><br><span class="line">            <span class="comment"># 右结点的右子树和左结点的左子树比较</span></span><br><span class="line">            <span class="comment"># 右结点的左子树和左结点的右子树比较</span></span><br><span class="line">            <span class="keyword">return</span> dfs(left.left, right.right) <span class="keyword">and</span> dfs(left.right, right.left)</span><br><span class="line">        <span class="keyword">return</span> dfs(root.left, root.right)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;symmetric-tree&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#symmetric-tree&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/symmetric-tree/&quot;&gt;symm</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>invert-binary-tree</title>
    <link href="https://cyccyyycyc.github.io/2022/10/25/invert-binary-tree/"/>
    <id>https://cyccyyycyc.github.io/2022/10/25/invert-binary-tree/</id>
    <published>2022-10-25T11:11:03.000Z</published>
    <updated>2022-10-25T11:13:33.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="invert-binary-tree"><a class="markdownIt-Anchor" href="#invert-binary-tree"></a> <a href="https://leetcode.cn/problems/invert-binary-tree/">invert-binary-tree</a></h1><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="comment"># 三条语句顺序无影响</span></span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            self.invertTree(root.left)</span><br><span class="line">            self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;invert-binary-tree&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#invert-binary-tree&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/invert-binary</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>maximum-depth-of-binary-tree</title>
    <link href="https://cyccyyycyc.github.io/2022/10/24/maximum-depth-of-binary-tree/"/>
    <id>https://cyccyyycyc.github.io/2022/10/24/maximum-depth-of-binary-tree/</id>
    <published>2022-10-24T03:59:53.000Z</published>
    <updated>2022-10-24T04:30:42.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="maximum-depth-of-binary-tree"><a class="markdownIt-Anchor" href="#maximum-depth-of-binary-tree"></a> <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">maximum-depth-of-binary-tree</a></h1><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><h2 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> dfs</h2><p>递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right))</span><br></pre></td></tr></table></figure><h2 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> bfs</h2><p>模拟队列实现层次遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            q = collections.deque()</span><br><span class="line">            q.append(root)</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(q):</span><br><span class="line">                depth += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                    tmp = q.popleft()</span><br><span class="line">                    <span class="keyword">if</span> tmp.left:</span><br><span class="line">                        q.append(tmp.left)</span><br><span class="line">                    <span class="keyword">if</span> tmp.right:</span><br><span class="line">                        q.append(tmp.right)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;maximum-depth-of-binary-tree&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#maximum-depth-of-binary-tree&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/pr</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>linked-list-cycle</title>
    <link href="https://cyccyyycyc.github.io/2022/10/24/linked-list-cycle/"/>
    <id>https://cyccyyycyc.github.io/2022/10/24/linked-list-cycle/</id>
    <published>2022-10-24T03:43:30.000Z</published>
    <updated>2022-10-24T03:50:26.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linked-list-cycle"><a class="markdownIt-Anchor" href="#linked-list-cycle"></a> <a href="https://leetcode.cn/problems/linked-list-cycle/">linked-list-cycle</a></h1><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><h2 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h2><p>用一个集合来存储已经访问过的结点（不是val），遍历访问时，判断当前结点是否已经访问过。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            seen.add(head)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="快慢指针"><a class="markdownIt-Anchor" href="#快慢指针"></a> 快慢指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> head:</span><br><span class="line">            slow = fast = head</span><br><span class="line">            <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> slow == fast:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linked-list-cycle&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linked-list-cycle&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/linked-list-cyc</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>plus-one</title>
    <link href="https://cyccyyycyc.github.io/2022/10/24/plus-one/"/>
    <id>https://cyccyyycyc.github.io/2022/10/24/plus-one/</id>
    <published>2022-10-24T03:20:57.000Z</published>
    <updated>2022-10-24T03:26:38.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="plus-one"><a class="markdownIt-Anchor" href="#plus-one"></a> <a href="https://leetcode.cn/problems/plus-one/">plus-one</a></h1><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>从后往前找，9则置0，找到第一个不为9的+1返回。若全为9则在0位插入一个1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        l = <span class="built_in">len</span>(digits)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> digits[i] <span class="keyword">is</span> <span class="number">9</span>:</span><br><span class="line">                digits[i] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> i:</span><br><span class="line">                    digits.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digits[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;plus-one&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#plus-one&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/plus-one/&quot;&gt;plus-one&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;给</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>merge-sorted-array</title>
    <link href="https://cyccyyycyc.github.io/2022/10/24/merge-sorted-array/"/>
    <id>https://cyccyyycyc.github.io/2022/10/24/merge-sorted-array/</id>
    <published>2022-10-24T02:43:07.000Z</published>
    <updated>2022-10-24T02:48:59.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="merge-sorted-array"><a class="markdownIt-Anchor" href="#merge-sorted-array"></a> <a href="https://leetcode.cn/problems/merge-sorted-array/">merge-sorted-array</a></h1><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><h2 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> Sort</h2><p>哈哈哈哈哈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums1[m:] = nums2</span><br><span class="line">        nums1.sort()</span><br></pre></td></tr></table></figure><h2 id="倒序遍历"><a class="markdownIt-Anchor" href="#倒序遍历"></a> 倒序遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p1, p2, p3 = m-<span class="number">1</span>, n-<span class="number">1</span>, n+m-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1&gt;=<span class="number">0</span> <span class="keyword">and</span> p2&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] &gt; nums2[p2]):</span><br><span class="line">                nums1[p3] = nums1[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[p3] = nums2[p2]</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            p3 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p2&gt;=<span class="number">0</span> <span class="keyword">and</span> p3&gt;=<span class="number">0</span>:</span><br><span class="line">            nums1[p3] = nums2[p2]</span><br><span class="line">            p2 -= <span class="number">1</span></span><br><span class="line">            p3 -= <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;merge-sorted-array&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#merge-sorted-array&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/merge-sorted-</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>implement-stack-using-queues</title>
    <link href="https://cyccyyycyc.github.io/2022/10/24/implement-stack-using-queues/"/>
    <id>https://cyccyyycyc.github.io/2022/10/24/implement-stack-using-queues/</id>
    <published>2022-10-24T02:07:25.000Z</published>
    <updated>2022-10-24T02:14:06.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="implement-stack-using-queues"><a class="markdownIt-Anchor" href="#implement-stack-using-queues"></a> <a href="https://leetcode.cn/problems/implement-stack-using-queues/">implement-stack-using-queues</a></h1><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现 MyStack 类：</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//将元素 x 压入栈顶。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> <span class="comment">//移除并返回栈顶元素。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> <span class="comment">//返回栈顶元素。</span></span><br><span class="line">boolean <span class="title function_">empty</span><span class="params">()</span> <span class="comment">//如果栈是空的，返回 true ；否则，返回 false 。</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p><h2 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.st = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.st.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        tmp = self.st[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">del</span> self.st[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.st[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.st)==<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><h2 id="dequeue-left"><a class="markdownIt-Anchor" href="#dequeue-left"></a> Dequeue-left</h2><p>双端队列模拟，左边为栈顶</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.q = collections.deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.q.appendleft(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.q.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.q[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.q)==<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><h2 id="dequeue-right"><a class="markdownIt-Anchor" href="#dequeue-right"></a> Dequeue-right</h2><p>双端队列，右边为栈顶模拟</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.q = collections.deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.q.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.q.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.q[<span class="built_in">len</span>(self.q)-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.q)==<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;implement-stack-using-queues&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#implement-stack-using-queues&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/pr</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>best-time-to-buy-and-sell-stock</title>
    <link href="https://cyccyyycyc.github.io/2022/10/23/best-time-to-buy-and-sell-stock/"/>
    <id>https://cyccyyycyc.github.io/2022/10/23/best-time-to-buy-and-sell-stock/</id>
    <published>2022-10-23T15:14:26.000Z</published>
    <updated>2022-10-23T15:32:15.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="best-time-to-buy-and-sell-stock"><a class="markdownIt-Anchor" href="#best-time-to-buy-and-sell-stock"></a> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">best-time-to-buy-and-sell-stock</a></h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>实际上就是找到一个 i&lt;j, max(prices[j] - prices[i])</p><h2 id="暴力穷举"><a class="markdownIt-Anchor" href="#暴力穷举"></a> 暴力穷举</h2><p>时间复杂度O(n^2)，超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(prices)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">                res = <span class="built_in">max</span>(prices[j]-prices[i], res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="一次遍历"><a class="markdownIt-Anchor" href="#一次遍历"></a> 一次遍历</h2><p>思路：遍历一次，对于第i天记录此前价格最低点，假设在此前价格最低点买进，当天卖出，记录最大收益值。</p><p>时间复杂度O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices)==<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(prices)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        min_price = prices[<span class="number">0</span>]</span><br><span class="line">        max_income = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="comment"># 若今天卖出，获得最大收益是多少？是否是当前最大收益？</span></span><br><span class="line">            max_income = <span class="built_in">max</span>(max_income, price-min_price)</span><br><span class="line">            <span class="comment"># 更新当前价格最低点</span></span><br><span class="line">            min_price = <span class="built_in">min</span>(min_price, price)</span><br><span class="line">        <span class="keyword">return</span> max_income</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;best-time-to-buy-and-sell-stock&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#best-time-to-buy-and-sell-stock&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>climbing-stairs</title>
    <link href="https://cyccyyycyc.github.io/2022/10/23/climbing-stairs/"/>
    <id>https://cyccyyycyc.github.io/2022/10/23/climbing-stairs/</id>
    <published>2022-10-23T13:54:31.000Z</published>
    <updated>2022-10-23T14:16:46.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="climbing-stairs"><a class="markdownIt-Anchor" href="#climbing-stairs"></a> <a href="https://leetcode.cn/problems/climbing-stairs/">climbing-stairs</a></h1><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>类似斐波那契数列</p><h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2><p>简单但超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.climbStairs(n-<span class="number">1</span>)+self.climbStairs(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2><p>时间复杂度O(n)，空间复杂度O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">return</span> res[n]</span><br><span class="line">        <span class="comment"># 注意这里上限是n+1-1=n</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            res.append(res[-<span class="number">1</span>] + res[-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> res[n]</span><br></pre></td></tr></table></figure><h2 id="动态规划-优化空间"><a class="markdownIt-Anchor" href="#动态规划-优化空间"></a> 动态规划-优化空间</h2><p>每次只用到n-1规模和n-2规模的解，所以可以只存前两个解。</p><p>时间复杂度O(n)，空间复杂度O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span> <span class="comment"># f(0)=1, f(1)=1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            a, b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h2 id="记忆dfs"><a class="markdownIt-Anchor" href="#记忆dfs"></a> 记忆dfs</h2><p>记忆性dfs自顶向下计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, flag</span>):</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> i==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> flag[i]==<span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                flag[i] = dfs(i-<span class="number">1</span>, flag) + dfs(i-<span class="number">2</span>, flag)</span><br><span class="line">            <span class="keyword">return</span> flag[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(n, (n+<span class="number">1</span>)*[<span class="string">&#x27;?&#x27;</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;climbing-stairs&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#climbing-stairs&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/climbing-stairs/&quot;&gt;c</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Hierarchical-Clustering</title>
    <link href="https://cyccyyycyc.github.io/2022/10/22/Hierarchical-Clustering/"/>
    <id>https://cyccyyycyc.github.io/2022/10/22/Hierarchical-Clustering/</id>
    <published>2022-10-22T11:10:17.000Z</published>
    <updated>2022-10-23T05:29:20.672Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="层次聚类-hierarchical-clustering"><a class="markdownIt-Anchor" href="#层次聚类-hierarchical-clustering"></a> 层次聚类 Hierarchical-Clustering</h1><h2 id="场景"><a class="markdownIt-Anchor" href="#场景"></a> 场景</h2><p>随着网络技术的发展，我们迎来了信息爆炸的时代。我们都知道现代大数据有4个特点：</p><ol><li>体量大 Volume</li><li>高速化 Velocity</li><li>多样化 Variety</li><li>低价值密度 Value</li></ol><p>未经处理的数据信息之间的联系往往较低，体量大而价值密度低。为了更好地挖掘数据价值，一个思路是找到数据之间的相似点进行度量和聚类，将数据点进行聚类，获得关联以更好地利用数据。网络世界中的推荐算法就是数据应用的一个典型例子。如淘宝、京东、拼多多等购物平台的商品推荐页面，谷歌、百度等搜索引擎的推荐回答，网易云音乐的日推歌曲…高效的推荐算法可以帮助我们快速的从体量庞大的信息流中定位到我们需要的有价值的数据，一定程度上便利了我们的生活。</p><p>推荐算法如何能实现推荐我们感兴趣的内容呢？我们往往会发现这样一个事实：品味相似的人会对相似的事物感兴趣。由此衍生出的一个思路是从相似的人出发：如找到兴趣爱好相同的两个人A和B，便可以将A感兴趣的内容推荐给B，由此推广到整个社区类群。在实际应用中，有协同过滤算法基于用户历史数据对用户进行群组划分并在此基础上推荐相似的物品，挖掘用户潜在兴趣。</p><p>在协同过滤中实现聚类有较多方法，本实验选择自底向上的层次聚类进行复现。</p><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p>先明确我们要实现什么：我们有一些离散的无关联的数据点，想要衡量它们之间的相似度，并以此为准则进行聚类。</p><p>那么这就要解决2个问题：</p><ol><li>相似度如何定义？</li><li>如何评估聚类的效果？</li></ol><p>首先，关于相似度定义的问题，需要定义一个函数来进行样本距离的衡量。如：</p><ol><li>Single-Linkage最短距离法：取两个类中距离最近的两个样本的距离作为两个集合的距离。</li><li>Complete-Linkage最长距离法：取两个集合中距离最远的两个点的距离作为两个集合的距离。</li><li>Average-linkage中间距离法：取两两距离的平均值作为两个集合之间的距离。</li><li>类平均法：取两两距离的中值作为两个集合之间的距离。</li></ol><p>四种方法各有特点：</p><ol><li>最短距离法相对限制较少，最终会得到一个相对松散的社群。</li><li>最长距离法相对限制较大。一个问题是：有可能两个类群已经很接近了，但由于单个样本的干扰便没有合并。</li><li>最短距离和最长距离法这考虑了某个有特点的数据，而没有考虑类内数据的整体特点，时间复杂度相对较低。</li><li>类平均法与取均值相比更能消除个别偏离样本对结果的干扰。</li></ol><p>其次，关于聚类效果评估的问题。容易发现，聚类和分类是不同的。对于分类问题，我们已经有了正确的标签，因此分类问题是一个有监督的学习。而聚类本身没有一个“正确”的结果，是一种无监督的学习。因为聚类没有一个确定的答案，目前尚未有一个效果较好的的评测指标评价聚类效果，更多的是靠数据可视化和人工评测效果。</p><p>层次聚类有两种思路：</p><ol><li>自底向上的凝聚法：凝聚法指的是初始时将每个样本点当做一个类簇，然后依据相似度合并这些初始的类簇，直到达到某种条件或者达到设定的分类数目。</li><li>自顶向下的分裂法：初始时将所有的样本归为一个类簇，然后依据相似度进行逐渐的分裂，直到达到某种条件或者达到设定的分类数目。</li></ol><h2 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h2><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ol><li>距离度量函数可以任意定义，较为灵活。</li><li>层次聚类结果是一个树状图，包含关系结构清晰，一个结点可以属于多个类。</li><li>一次性获得整个聚类树，可以直接根据需要对聚类树进行横向切割获得指定数量的类簇。</li></ol><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3><ol><li>计算复杂度大</li><li>贪心算法获得局部最优，不一定是全局最优解。</li><li>层次聚类具有不可逆性，一旦聚类结果形成，想要就不能重新合并来优化聚类性能。</li><li>对于不同的问题，需要人为选择合适的距离度量函数、终止条件和参数。</li></ol><h2 id="实现步骤"><a class="markdownIt-Anchor" href="#实现步骤"></a> 实现步骤</h2><ol><li>移除网络中的所有边，得到有 n 个孤立节点，每个节点作为一个集合。</li><li>两两计算相似度</li><li>根据选取相似度最小的两个结点进行合并</li><li>重复2和3直到满足条件终止，形成树状图</li><li>根据实际需求横切树状图，获得聚类的社区结构</li></ol><h2 id="代码执行"><a class="markdownIt-Anchor" href="#代码执行"></a> 代码执行</h2><h3 id="依赖"><a class="markdownIt-Anchor" href="#依赖"></a> 依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python==3.8.8</span><br><span class="line">numpy==1.23.3</span><br><span class="line">scipy==1.7.0</span><br><span class="line">scikit-learn==1.1.2</span><br><span class="line">matplotlib==3.5.3</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h3><h4 id="导入库"><a class="markdownIt-Anchor" href="#导入库"></a> 导入库</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.cluster <span class="keyword">import</span> hierarchy</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> AgglomerativeClustering</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><h4 id="导入数据"><a class="markdownIt-Anchor" href="#导入数据"></a> 导入数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入数据集</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">iris_data = iris.data</span><br><span class="line"><span class="built_in">print</span>(iris_data.shape, iris_data.dtype)</span><br><span class="line"><span class="comment"># output:(150, 4) float64</span></span><br></pre></td></tr></table></figure><h4 id="数据预处理"><a class="markdownIt-Anchor" href="#数据预处理"></a> 数据预处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据集预处理</span></span><br><span class="line"></span><br><span class="line">data = np.array(iris_data[:, <span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(data.shape)</span><br><span class="line"><span class="comment"># output:(150, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据的每一个特征缩放到给定的范围(0,1)</span></span><br><span class="line">min_max_scaler = preprocessing.MinMaxScaler()</span><br><span class="line">data_M = min_max_scaler.fit_transform(data)</span><br></pre></td></tr></table></figure><h4 id="层次聚类树状图"><a class="markdownIt-Anchor" href="#层次聚类树状图"></a> 层次聚类树状图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">6</span>))</span><br><span class="line">plt.title(<span class="string">&quot;Dendrograms&quot;</span>)  </span><br><span class="line"><span class="comment">#  ward：集合间距离等于两类对象之间的最小距离。（即最短距离法single-linkage聚类）</span></span><br><span class="line"><span class="comment">#  计算距离的方法，可以是 “euclidean”（即 “l2”，欧氏距离）</span></span><br><span class="line">Z = hierarchy.linkage(data_scaled, method=<span class="string">&#x27;ward&#x27;</span>, metric=<span class="string">&#x27;euclidean&#x27;</span>)</span><br><span class="line">p = hierarchy.dendrogram(Z, <span class="number">0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2022/10/22/Hierarchical-Clustering/1.jpg" alt="1"></p><h4 id="层次聚类分布图"><a class="markdownIt-Anchor" href="#层次聚类分布图"></a> 层次聚类分布图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  ward：集合间距离等于两类对象之间的最小距离。（即最短距离法single-linkage聚类）</span></span><br><span class="line"><span class="comment">#  计算距离的方法，可以是 “euclidean”（即 “l2”，欧氏距离）</span></span><br><span class="line">ac = AgglomerativeClustering(n_clusters=<span class="number">6</span>, affinity=<span class="string">&#x27;euclidean&#x27;</span>, linkage=<span class="string">&#x27;ward&#x27;</span>)</span><br><span class="line">ac.fit(data_scaled)</span><br><span class="line">labels = ac.fit_predict(data_scaled)</span><br><span class="line">plt.scatter(data_scaled[:,<span class="number">0</span>], data_scaled[:,<span class="number">1</span>], c=labels)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2022/10/22/Hierarchical-Clustering/2.jpg" alt="2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;层次聚类-hierarchical-clustering&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#层次聚类-hierarchical-clustering&quot;&gt;&lt;/a&gt; 层次聚类 Hierarchical-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>move-zeros</title>
    <link href="https://cyccyyycyc.github.io/2022/10/22/move-zeros/"/>
    <id>https://cyccyyycyc.github.io/2022/10/22/move-zeros/</id>
    <published>2022-10-22T06:03:13.000Z</published>
    <updated>2022-10-23T13:55:43.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="move-zeros"><a class="markdownIt-Anchor" href="#move-zeros"></a> <a href="https://leetcode.cn/problems/move-zeroes/">move-zeros</a></h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><h2 id="快慢指针"><a class="markdownIt-Anchor" href="#快慢指针"></a> 快慢指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow = fast = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num != <span class="number">0</span>:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 尾部置零</span></span><br><span class="line">        <span class="keyword">while</span>(slow &lt; fast):</span><br><span class="line">            nums[slow] = <span class="number">0</span></span><br><span class="line">            slow += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="move-append"><a class="markdownIt-Anchor" href="#move-append"></a> move &amp; append</h2><p>这个相对来说慢很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> <span class="keyword">in</span> nums:</span><br><span class="line">            nums.remove(<span class="number">0</span>)</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (cnt):</span><br><span class="line">            nums.append(<span class="number">0</span>)</span><br><span class="line">            cnt -= <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;move-zeros&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#move-zeros&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode.cn/problems/move-zeroes/&quot;&gt;move-zeros&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://cyccyyycyc.github.io/categories/Algorithm/"/>
    
    
    <category term="leetcode" scheme="https://cyccyyycyc.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
