{"meta":{"title":"Cy","subtitle":"","description":"","author":"Cy","url":"https://cyccyyycyc.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-10-21T03:38:20.240Z","updated":"2022-10-21T03:38:20.240Z","comments":false,"path":"about/index.html","permalink":"https://cyccyyycyc.github.io/about/index.html","excerpt":"","text":"…"},{"title":"404 Not Found：该页无法显示","date":"2022-10-21T03:37:46.249Z","updated":"2022-10-20T06:51:59.327Z","comments":false,"path":"/404.html","permalink":"https://cyccyyycyc.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2022-10-21T03:38:25.782Z","updated":"2022-10-20T06:51:59.331Z","comments":false,"path":"books/index.html","permalink":"https://cyccyyycyc.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-10-21T03:31:52.114Z","updated":"2022-10-20T06:51:59.333Z","comments":true,"path":"links/index.html","permalink":"https://cyccyyycyc.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-10-21T03:38:33.631Z","updated":"2022-10-20T06:51:59.332Z","comments":false,"path":"categories/index.html","permalink":"https://cyccyyycyc.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-10-20T06:51:59.334Z","updated":"2022-10-20T06:51:59.334Z","comments":false,"path":"repository/index.html","permalink":"https://cyccyyycyc.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-10-20T06:51:59.335Z","updated":"2022-10-20T06:51:59.335Z","comments":false,"path":"tags/index.html","permalink":"https://cyccyyycyc.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode-0","slug":"LeetCode-0","date":"2022-10-27T11:52:43.000Z","updated":"2022-10-27T13:57:44.140Z","comments":true,"path":"2022/10/27/LeetCode-0/","link":"","permalink":"https://cyccyyycyc.github.io/2022/10/27/LeetCode-0/","excerpt":"","text":"简单题 two-sum 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 例如： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 遍历 空间复杂度O(n) 时间复杂度O(n) 123456789class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: dict = &#123;&#125; for i, n in enumerate(nums): x = target - n if x in dict: return [dict[x], i] else: dict[n] = i 暴力 两层循环，时间复杂度O(n^2) 注意：不能考虑重复元素 1234567class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: l = len(nums) for i in range(l): for j in range(i+1, l, 1): if nums[i] + nums[j] == target: return [i, j] 删除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 反向遍历POP 注意索引 123456class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: for i in range(len(nums)-1, -1, -1): if(nums[i] == val): nums.pop(i) return len(nums) 2 记录val值个数，一次循环，元素前移 12345678910class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: k = 0 l = len(nums) for i, n in enumerate(nums): nums[i-k] = nums[i] if(n==val): k = k+1 return l-k 双指针 l为新数组索引，r为原数组索引。 123456789class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: l = 0 r = 0 for r in range(len(nums)): if(nums[r]!=val): nums[l]=nums[r] l = l+1 return l count &amp; remove 123456class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: a = nums.count(val) # 计算数组nums中val值的个数 for i in range(a): nums.remove(val) return len(nums) index &amp; del 12345class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: while val in nums: del nums[nums.index(val)] return len(nums) 存在重复元素 给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。 set() 123class Solution: def containsDuplicate(self, nums: List[int]) -&gt; bool: return len(nums)!=len(set(nums)) 删除有序数组中的重复项 删除有序数组中的重复项 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。 将最终结果插入 nums 的前 k 个位置后返回 k 。 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 倒序POP 注意索引 123456class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: for i in range(len(nums)-1, 0, -1): if (nums[i] == nums[i-1]): nums.pop(i) return len(nums) 快慢指针 12345678910class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: fast = 1 slow = 0 while(fast &lt; len(nums)): if(nums[fast] != nums[slow]): slow = slow + 1 nums[slow] = nums[fast] fast = fast + 1 return slow+1 数组中的重复数字 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 哈希字典 123456789class Solution: def findRepeatNumber(self, nums: List[int]) -&gt; int: dic = set() for i in range(0, len(nums), 1): if nums[i] in dic: return nums[i] else: dic.add(nums[i]) return -1 原地交换 数组长度为n，数字范围在[0, n-1]，且有数字重复。所以可以调整索引数值一一对应，当发生冲突则返回。 1234567891011class Solution: def findRepeatNumber(self, nums: List[int]) -&gt; int: i = 0 while i &lt; len(nums): if nums[i] != i: if nums[nums[i]] == nums[i]: return nums[i] nums[nums[i]], nums[i] = nums[i], nums[nums[i]] else: i += 1 return -1 独苗 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 异或 任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。 任何数和其自身做异或运算，结果是 0，即a⊕a=0。 异或运算满足交换律。 因此，把所有数值做异或运算即可得到结果。 123456class Solution: def singleNumber(self, nums: List[int]) -&gt; int: ans = 0 for i in range(len(nums)): ans = ans ^ nums[i] return ans 查找目标值 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 二分 123456789101112class Solution: def search(self, nums: List[int], target: int) -&gt; int: l, r = 0, len(nums)-1 while l &lt;= r: m = (l+r)//2 if target == nums[m]: return m elif target&gt;nums[m]: l = m + 1 else: r = m - 1 return -1 List.index() 这个耗时还少，赢麻了 123456class Solution: def search(self, nums: List[int], target: int) -&gt; int: try: return nums.index(target) except ValueError: return -1 查找插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 顺序查找 时间复杂度O(n) 123456class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: for i, n in enumerate(nums): if(target &lt;= n): return i return i+1 二分查找 时间复杂度为 O(log n) 123456789101112class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: l, r = 0, len(nums) - 1 while(l &lt;= r): mid = (l+r)//2 if(nums[mid]&gt;target): r = mid - 1 elif (nums[mid]&lt;target): l = mid + 1 else: return mid return l 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 暴力解法 逐次遍历，两两找最长前缀。 注意每次拿前缀和新的字符串比较时，用切片保证前缀长度比新字符串小。 12345678910111213141516class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: prefix = &quot;&quot; if not strs: return prefix else: prefix = strs[0] for str0 in strs: # 前缀长度一定是最小的 if len(str0) &lt; len(prefix): prefix = prefix[0: len(str0)] for i in range(min(len(str0), len(prefix))): if prefix[i]!= str0[i]: prefix = prefix[0:i] break return prefix 字典排序 用min和max获得字典排序的最小串和最大串，直接找两者最大前缀 123456789class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if not strs: return &quot;&quot; str0, str1 = min(strs), max(strs) for i in range(len(str0)): if str0[i]!=str1[i]: return str0[:i] return str0 压缩 set函数生成集合，集合中不能有相同元素，可以用集合长度确定strs相同位置的元素是否相同。 123456789class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: prefix = &quot;&quot; for i in list(zip(*strs)): if len(set(i))==1: prefix += i[0] else: break return prefix 合并有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 sort 哈哈哈哈哈 1234567class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums1 in-place instead. &quot;&quot;&quot; nums1[m:] = nums2 nums1.sort() 倒序遍历 123456789101112131415161718class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums1 in-place instead. &quot;&quot;&quot; p1, p2, p3 = m-1, n-1, n+m-1 while p1&gt;=0 and p2&gt;=0: if(nums1[p1] &gt; nums2[p2]): nums1[p3] = nums1[p1] p1 -= 1 else: nums1[p3] = nums2[p2] p2 -= 1 p3 -= 1 while p2&gt;=0 and p3&gt;=0: nums1[p3] = nums2[p2] p2 -= 1 p3 -= 1 加1 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 反向遍历 从后往前找，9则置0，找到第一个不为9的+1返回。若全为9则在0位插入一个1。 123456789101112class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: l = len(digits) for i in range(l-1, -1, -1): if digits[i] is 9: digits[i] = 0 if not i: digits.insert(0, 1) else: digits[i] += 1 break return digits 移0 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 快慢指针 123456789101112131415class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; slow = fast = 0 for num in nums: if num != 0: nums[slow] = nums[fast] slow += 1 fast += 1 # 尾部置零 while(slow &lt; fast): nums[slow] = 0 slow += 1 move &amp; append 这个相对来说慢很多 123456789101112class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; cnt = 0 while 0 in nums: nums.remove(0) cnt += 1 while (cnt): nums.append(0) cnt -= 1 两个数组交集 给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 set.intersection() 求两个集合的交集。 123class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return list(set.intersection(set(nums1), set(nums2))) 123class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return list(set(nums1).intersection(set(nums2))) &amp; 123class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return list(set(nums1) &amp; set(nums2)) 两个数组交集ii 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 Counter &amp; 1234567class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: dic = (Counter(nums1) &amp; Counter(nums2)) res = [] for i in dic.keys(): res += dic[i]*[i] return res 最后的单词 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。 单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。 反向遍历查找 反向找第一个字母，找到则记录tail word的长度 123456789class Solution: def lengthOfLastWord(self, s: str) -&gt; int: tail = 0 for i in range(len(s)-1, -1, -1): if s[i]!=&#x27; &#x27;: while i &gt; -1 and s[i] != &#x27; &#x27;: tail += 1 i -= 1 return tail str.split() 123class Solution: def lengthOfLastWord(self, s: str) -&gt; int: return len(s.split()[-1]) 替换空格 请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。 str.replace() 123class Solution: def replaceSpace(self, s: str) -&gt; str: return s.replace(&#x27; &#x27;, &#x27;%20&#x27;) str.split() and str.join() 123class Solution: def replaceSpace(self, s: str) -&gt; str: return &#x27;%20&#x27;.join(s.split(&#x27; &#x27;)) 反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 str.reverse() 123456class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; s.reverse() 切片 123456class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; s[:] = s[::-1] 双指针 1234567891011class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; l = 0 r = len(s)-1 while l&lt;r: s[l], s[r] = s[r], s[l] l += 1 r -= 1 有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 Counter 123class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: return Counter(s)==Counter(t) 左旋转字符串 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。 切片 123class Solution: def reverseLeftWords(self, s: str, n: int) -&gt; str: return s[n:] + s[:n] list 字符串不能直接用下标赋值，通过list实现转换。 12345678class Solution: def reverseLeftWords(self, s: str, n: int) -&gt; str: st = [] for i in range(n, len(s)): st.append(s[i]) for i in range(0, n): st.append(s[i]) return &#x27;&#x27;.join(st) 用求余运算简化代码 1234567class Solution: def reverseLeftWords(self, s: str, n: int) -&gt; str: st = [] l = len(s) for i in range(n, l + n): st.append(s[i % l]) return &#x27;&#x27;.join(st) 二进制求和 给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。 bin() 123class Solution: def addBinary(self, a: str, b: str) -&gt; str: return bin(int(a, 2) + int(b, 2))[2:] 合并有序链表 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 递归 123456789101112# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]: if list1 and list2: if list1.val &gt; list2.val: list1, list2 = list2, list1 list1.next = self.mergeTwoLists(list1.next, list2) return list1 or list2 迭代 用带头节点的单链表统一操作 12345678910111213141516# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]: tmp = cur = ListNode(-1) # Head Node while list1 and list2: if list1.val &gt; list2.val: cur.next, list2 = list2, list2.next else: cur.next, list1 = list1, list1.next cur = cur.next cur.next = list1 if list1 else list2 return tmp.next 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 迭代 1234567891011121314# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: ans = None while head is not None: p = head.next head.next = ans ans = head head = p return ans 递归 12345678910111213# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: if not head or not head.next: return head last = self.reverseList(head.next) head.next.next = head head.next = None return last 环形链表 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 哈希表 用一个集合来存储已经访问过的结点（不是val），遍历访问时，判断当前结点是否已经访问过。 123456789101112131415# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def hasCycle(self, head: Optional[ListNode]) -&gt; bool: seen = set() while head: if head in seen: return True seen.add(head) head = head.next return False 快慢指针 12345678910111213141516# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def hasCycle(self, head: Optional[ListNode]) -&gt; bool: if head: slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False 链表中倒数第k个结点 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。 快慢指针 123456789101112131415# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def getKthFromEnd(self, head: ListNode, k: int) -&gt; ListNode: slow = fast = head for i in range(k): fast = fast.next while fast: slow = slow.next fast = fast.next return slow 相交链表 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 哈希字典 1234567891011121314151617181920# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]: dic = set() p = headA while p: dic.add(p) p = p.next p = headB while p: if p in dic: return p p = p.next return p 双指针 a+(b−c)=b+(a−c)=a+b−ca+(b-c)=b+(a-c)=a+b-c a+(b−c)=b+(a−c)=a+b−c 12345678910111213# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]: p, q = headA, headB while q != p: p = p.next if p else headB q = q.next if q else headA return q 去尾 对两个链表，裁剪最大相同长度的尾部，同时遍历。 123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]: p, q = headA, headB la, lb = 0, 0 # 计算链表A长度 while p: la += 1 p = p.next # 计算链表B长度 while q: lb +=1 q = q.next # 裁剪去头 while la &gt; lb: headA = headA.next la -= 1 while lb &gt; la: headB = headB.next lb -= 1 # 此时la==lb p, q = headA, headB while p and q: if p==q: return p p = p.next q = q.next return None 从尾到头打印链表 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 递归 123456789101112131415# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reversePrint(self, head: ListNode) -&gt; List[int]: re = [] def fun(p): if p: fun(p.next) re.append(p.val) fun(head) return re 正向遍历后翻转 12345678910111213# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reversePrint(self, head: ListNode) -&gt; List[int]: res = [] while head: res.append(head.val) head = head.next return res[::-1] 删除链表中的重复元素 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 遍历一次 1234567891011121314# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def deleteDuplicates(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: p = head while p and p.next: if p.val == p.next.val: p.next = p.next.next else: p = p.next return head 回文链表 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 快慢指针 1234567891011121314151617181920# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def isPalindrome(self, head: Optional[ListNode]) -&gt; bool: st = [] fast, slow = head, head while fast and fast.next: fast, slow = fast.next.next, slow.next while slow: st.append(slow.val) slow = slow.next p = head while st: if st.pop()!=p.val: return False p = p.next return True 翻转 12345678910111213# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def isPalindrome(self, head: Optional[ListNode]) -&gt; bool: st = [] p = head while p: st.append(p.val) p = p.next return st[::1]==st[::-1] 二叉树最大深度 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 DFS 递归 1234567891011# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def maxDepth(self, root: Optional[TreeNode]) -&gt; int: if not root: return 0 return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right)) BFS 模拟队列实现层次遍历 12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def maxDepth(self, root: Optional[TreeNode]) -&gt; int: depth = 0 if root: q = collections.deque() q.append(root) while len(q): depth += 1 for i in range(len(q)): tmp = q.popleft() if tmp.left: q.append(tmp.left) if tmp.right: q.append(tmp.right) return depth 二叉树最小深度 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 **说明：**叶子节点是指没有子节点的节点。 递归 123456789101112131415161718# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def minDepth(self, root: Optional[TreeNode]) -&gt; int: if root: if root.right and root.left: return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 if root.right: return self.minDepth(root.right) + 1 if root.left: return self.minDepth(root.left) + 1 # 遇到叶子结点则返回 return 1 return 0 BFS 123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def minDepth(self, root: Optional[TreeNode]) -&gt; int: depth = 0 if root: q = [root] while q: depth += 1 for i in range(len(q)): tmp = q[0] del q[0] if tmp.left: q.append(tmp.left) if tmp.right: q.append(tmp.right) # 遇到叶子结点则返回深度 if not tmp.right and not tmp.left: return depth return depth 翻转二叉树 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 递归 1234567891011121314# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]: if root: # 三条语句顺序无影响 root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root 对称树 给你一个二叉树的根节点 root ， 检查它是否轴对称。 递归 123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool: if not root: return True # 送入镜像结点 def dfs(left, right): # 左右结点为空 if not (left or right): return True # 单边结点为空 if not (left and right): return False # 左右结点不为空 # 当值不等，返回0 if left.val != right.val: return False # 当值相等 # 右结点的右子树和左结点的左子树比较 # 右结点的左子树和左结点的右子树比较 return dfs(left.left, right.right) and dfs(left.right, right.left) return dfs(root.left, root.right) 路径总和 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 递归 1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; bool: if root: # 若无左右结点，则为叶子结点 if not root.left and not root.right: return True if targetSum==root.val else False return self.hasPathSum(root.left, targetSum-root.val) or self.hasPathSum(root.right, targetSum-root.val) # root为none则返回False return False 二叉树中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 递归 12345678910111213141516# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: trl = [] def inorder(r): if r: inorder(r.left) trl.append(r.val) inorder(r.right) inorder(root) return trl 罗马数字 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。 字典 数组记录，小数在大数前面，则小数取负，最后全部相加。 1234567891011121314class Solution: def romanToInt(self, s: str) -&gt; int: dict = &#123;&#x27;I&#x27;:1, &#x27;V&#x27;:5, &#x27;X&#x27;:10, &#x27;L&#x27;:50, &#x27;C&#x27;:100, &#x27;D&#x27;:500, &#x27;M&#x27;:1000&#125; st = [0] top = ans = 0 for i in s: st.append(dict[i]) # 小数在大数前面，则小数取负 if(dict[i]&gt;st[top]): st[top] = - st[top] top += 1 for i in st: ans += i return ans 爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 类似斐波那契数列 递归 简单但超时 12345class Solution: def climbStairs(self, n: int) -&gt; int: if n==0 or n==1: return 1 return self.climbStairs(n-1)+self.climbStairs(n-2) 动态规划 自底向上求解，时间复杂度O(n)，空间复杂度O(n) 123456789class Solution: def climbStairs(self, n: int) -&gt; int: res = [1, 1] if(n&lt;2): return res[n] # 注意这里上限是n+1-1=n for i in range(2, n+1): res.append(res[-1] + res[-2]) return res[n] 动态规划-优化空间 每次只用到n-1规模和n-2规模的解，所以可以只存前两个解。 时间复杂度O(n)，空间复杂度O(1) 123456class Solution: def climbStairs(self, n: int) -&gt; int: a, b = 1, 1 # f(0)=1, f(1)=1 for i in range(2, n+1): a, b = b, a+b return b 记忆dfs 记忆性dfs自顶向下计算 12345678910class Solution: def climbStairs(self, n: int) -&gt; int: def dfs(i, flag): if i==0 or i==1: return 1 if flag[i]==&#x27;?&#x27;: flag[i] = dfs(i-1, flag) + dfs(i-2, flag) return flag[i] return dfs(n, (n+1)*[&#x27;?&#x27;]) 炒股 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 实际上就是找到一个 i&lt;j, max(prices[j] - prices[i]) 暴力穷举 时间复杂度O(n^2)，超时 1234567class Solution: def maxProfit(self, prices: List[int]) -&gt; int: res = 0 for i in range(0, len(prices)-1): for j in range(i+1, len(prices)): res = max(prices[j]-prices[i], res) return res 一次遍历 思路：遍历一次，对于第i天记录此前价格最低点，假设在此前价格最低点买进，当天卖出，记录最大收益值。 时间复杂度O(n) 123456789101112class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if len(prices)==0 or len(prices)==1: return 0 min_price = prices[0] max_income = 0 for price in prices: # 若今天卖出，获得最大收益是多少？是否是当前最大收益？ max_income = max(max_income, price-min_price) # 更新当前价格最低点 min_price = min(min_price, price) return max_income 用队列实现栈 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 123456//实现 MyStack 类：void push(int x) //将元素 x 压入栈顶。int pop() //移除并返回栈顶元素。int top() //返回栈顶元素。boolean empty() //如果栈是空的，返回 true ；否则，返回 false 。 注意： 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 List 1234567891011121314151617181920212223242526class MyStack: def __init__(self): self.st = [] def push(self, x: int) -&gt; None: self.st.append(x) def pop(self) -&gt; int: tmp = self.st[-1] del self.st[-1] return tmp def top(self) -&gt; int: return self.st[-1] def empty(self) -&gt; bool: return len(self.st)==0# Your MyStack object will be instantiated and called as such:# obj = MyStack()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.top()# param_4 = obj.empty() Dequeue-left 双端队列模拟，左边为栈顶 123456789101112131415161718192021222324class MyStack: def __init__(self): self.q = collections.deque() def push(self, x: int) -&gt; None: self.q.appendleft(x) def pop(self) -&gt; int: return self.q.popleft() def top(self) -&gt; int: return self.q[0] def empty(self) -&gt; bool: return len(self.q)==0# Your MyStack object will be instantiated and called as such:# obj = MyStack()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.top()# param_4 = obj.empty() Dequeue-right 双端队列，右边为栈顶模拟 123456789101112131415161718192021222324class MyStack: def __init__(self): self.q = collections.deque() def push(self, x: int) -&gt; None: self.q.append(x) def pop(self) -&gt; int: return self.q.pop() def top(self) -&gt; int: return self.q[len(self.q)-1] def empty(self) -&gt; bool: return len(self.q)==0# Your MyStack object will be instantiated and called as such:# obj = MyStack()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.top()# param_4 = obj.empty() 有效的括号 给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 栈 利用字典构造匹配关系 1234567891011class Solution: def isValid(self, s: str) -&gt; bool: dict = &#123;&#x27;(&#x27;:&#x27;)&#x27;, &#x27;&#123;&#x27;:&#x27;&#125;&#x27;, &#x27;[&#x27;:&#x27;]&#x27;, &#x27;?&#x27;:&#x27;?&#x27;&#125; stack = [&#x27;?&#x27;] for c in s: if c in dict: stack.append(c) elif dict[stack.pop()] != c: return False return len(stack)==1 回文数 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 例如，121 是回文，而 123 不是。 直接计算 如果x小于0则必不是回文数 如果x大于0则计算其倒序数值，比较和原x是否相等 1234567891011class Solution: def isPalindrome(self, x: int) -&gt; bool: if x&lt;0: return False else: cur = 0 num = x while(num&gt;0): cur = cur*10 + num%10 num = num//10 return cur == x 反向切片 123class Solution: def isPalindrome(self, x: int) -&gt; bool: return str(x) == str(x)[::-1] x的平方根 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。 牛顿迭代法 12345678class Solution: def mySqrt(self, x: int) -&gt; int: if x == 0: return 0 x0, x1 = float(x), float(&#x27;inf&#x27;) while x1-x0 &gt; 1e-7: x0, x1 = (x0 + x / x0) / 2, x0 return int(x0) 二分查找 123456789101112class Solution: def mySqrt(self, x: int) -&gt; int: l, r, ans = 0, x, -1 while l&lt;=r: m = (l+r)//2 if m**2 &lt;= x: l = m + 1 ans = m else: r = m - 1 return ans math 123456class Solution: def mySqrt(self, x: int) -&gt; int: if x==0: return 0 ans = int(math.exp(0.5 * math.log(x))) return ans+1 if (ans+1)**2&lt;=x else ans 123class Solution: def mySqrt(self, x: int) -&gt; int: return int(math.pow(x, 0.5)) majority-element 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 排序 排序后取nums[n//2] 1234class Solution: def majorityElement(self, nums: List[int]) -&gt; int: nums.sort() return nums[len(nums)//2] 字典 123class Solution: def majorityElement(self, nums: List[int]) -&gt; int: return Counter(nums).most_common(1)[0][0] 1234class Solution: def majorityElement(self, nums: List[int]) -&gt; int: counts = collections.Counter(nums) return max(counts.keys(), key=counts.get) 123class Solution: def majorityElement(self, nums: List[int]) -&gt; int: return max(set(nums), key=nums.count) 摩尔投票 12345678910class Solution: def majorityElement(self, nums: List[int]) -&gt; int: count = 0 candidate = None for num in nums: # 票数为0换候选人 if count==0: candidate = num count += (1 if candidate == num else -1) return candidate majority-element-ii 给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。 摩尔投票 选出2个有希望超过⌊ n/3 ⌋的候选人，统计他们的票数是否真的超过⌊ n/3 ⌋。 1234567891011121314151617181920212223242526272829303132class Solution: def majorityElement(self, nums: List[int]) -&gt; List[int]: vote1 = 0 vote2 = 0 candidate1 = None candidate2 = None for num in nums: if num==candidate1: vote1 += 1 elif num==candidate2: vote2 += 1 elif vote1==0: vote1 = 1 candidate1 = num elif vote2==0: vote2 = 1 candidate2 = num else: vote1 -= 1 vote2 -= 1 res = [] cnt1, cnt2 = 0, 0 for num in nums: if vote1&gt;0 and num==candidate1: cnt1 += 1 elif vote2&gt;0 and num==candidate2: cnt2 += 1 if cnt1 &gt; len(nums)//3: res.append(candidate1) if cnt2 &gt; len(nums)//3: res.append(candidate2) return res 哈希字典 12345678910111213class Solution: def majorityElement(self, nums: List[int]) -&gt; List[int]: dic = &#123;&#125; res = [] for num in nums: if num in dic: dic[num] += 1 else: dic[num] = 1 for i in dic.keys(): if dic[i] &gt; len(nums)//3 : res.append(i) return res","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cyccyyycyc.github.io/categories/Algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cyccyyycyc.github.io/tags/leetcode/"}]},{"title":"Adversarial Robustness by刘思佳","slug":"Adversarial-Robustness-by刘思佳","date":"2022-10-26T08:31:59.000Z","updated":"2022-10-26T08:56:23.432Z","comments":true,"path":"2022/10/26/Adversarial-Robustness-by刘思佳/","link":"","permalink":"https://cyccyyycyc.github.io/2022/10/26/Adversarial-Robustness-by%E5%88%98%E6%80%9D%E4%BD%B3/","excerpt":"","text":"观后感 Source The 6th Lecture 深度神经网络的对抗鲁棒性 攻击 ZO-SGD 对于黑盒的对抗攻击，优化问题不能求导，便将其转化为一个零阶(ZO zero-order)优化问题，他们证明了收敛性。 但是存在收敛速度慢的问题： 有偏差bias 方差较大 容易受到维度的影响，高维下收敛速度太慢。 ZO-signSGD 相比于ZO-SGD，ZO-signSGD对估计的梯度取了正负。 效果： 减少了估计的方差 收敛速度增加 但是同时也引入了新的问题：收敛精度下降，难以取得和ZO-SGD一样的最值。 ZO-Adam sign减少估计的方差，而换一种思路，自适应的学习率adaptive learning rate也可以降低估计方差。因此可以采用ZO-Adam优化方法。 防御 对抗攻击会修改图片的interpretation maps （CAM），造成了可解释性上的差异。 由此，刘思佳教授设计相应的可解释性上的距离度量，并证明了该距离大于图片对原本类和目标类的激活值之差。 将可解释性距离度量用于对抗训练，对有较大扰动的对抗攻击的鲁棒性提高效果很好，但是会使模型的精确性下降。 未来 不同领域之间的鲁棒性的迁移性 大规模鲁棒训练 与传统信息安全领域交叉的鲁棒机器学习 攻击逆向工程与对攻击者意图探明 对抗鲁棒性与神经网络多种性质之间的关系","categories":[{"name":"AISP","slug":"AISP","permalink":"https://cyccyyycyc.github.io/categories/AISP/"}],"tags":[{"name":"对抗鲁棒性","slug":"对抗鲁棒性","permalink":"https://cyccyyycyc.github.io/tags/%E5%AF%B9%E6%8A%97%E9%B2%81%E6%A3%92%E6%80%A7/"}]},{"title":"Towards Robust Representation by谢慈航","slug":"Towards-Robust-Representation-by谢慈航","date":"2022-10-26T07:25:03.000Z","updated":"2022-10-26T08:22:44.699Z","comments":true,"path":"2022/10/26/Towards-Robust-Representation-by谢慈航/","link":"","permalink":"https://cyccyyycyc.github.io/2022/10/26/Towards-Robust-Representation-by%E8%B0%A2%E6%85%88%E8%88%AA/","excerpt":"","text":"观后感 Source The 5th Lecture 鲁棒表示学习 AI下的DL分支目前发展迅猛，应用效果好，如： AlphaGo Rubik’s Cube（机器人解魔方） Self-Driving Cars(如特斯拉) … 而2013年对抗样本首次被提出，暴露了AI的脆弱性，也引发了人们的思考和关注：AI为什么不鲁棒？？ 脆弱性 Vuluerability （1）对抗样本影响各个领域： 分类 语义分割 目标检测 强化学习 Pose Estimation … （2）对抗样本具有一定迁移性：不同任务之间的对抗样本可以相互迁移 在黑盒攻击中，一个思路是利用对抗样本的迁移性。在本地代理模型Substitute Networks上生成对抗样本，用以迁移攻击目标模型。 （3）物理世界的对抗样本存在较大威胁性 修改结构：鲁棒性提高 中间层去噪 一个现象是：在pix级别原图和对抗样本没有很大区别，但经过神经网络的放大处理，在feature map上呈现出比较大的差异。（如deepfake检测） 中间层去噪：可以将图片去噪的经典方法（如中值滤波、均值滤波…）应用在中间层，防御对抗攻击。这个操作是为了提高模型鲁棒性，相应地，去噪操作会导致信息损失，模型精确度下降。 Denoising Block Design：对应优化模型架构，采用ResNet结构减少信息损失，提高模型精确度。 平滑的Function 往往鲁棒性对应着平滑连续的表示函数。Relu存在跳跃，可以采用一些连续平滑的激活函数（如GElu，Elu，SmoothRelu…)来增强鲁棒性。 用对抗样本进行数据增强 进行数据增强有很多方法： 很多方法都不具有普适性（如flip这样的处理，对于NLP, 强化学习等领域是不适用的） 对抗样本进行数据增强是一种通用的方法。 对抗训练 一般而言，对抗训练有时候会导致模型鲁棒性上升精确度下降。有一种思路是，先用对抗样本进行对抗训练后再用干净样本进行fine-tuning来提高准确度，但是这样模型可能会以往对抗训练中学到的东西。 Adv-Prop 以前就有人提出，训练时将对抗样本和正常样本同时输入网络（2个BN分别归一化处理，其它不做修改）。测试时丢掉对抗样本对应的BN，只要干净样本对应的BN。 未来 构建人和机器之间的合作，可解释性是一个重要的问题。我们需要知道AI何时可以解决问题，什么场景下会出Bug，很多时候，对于输出的结果（如分类的结果），我们更需要它给出原因，是依据什么得出了这个输出。 Q&amp;A （1）可以从什么角度出发来提高模型鲁棒性？ 数据：对抗训练学到更多特征 结构：更加平滑的函数表示 损失函数：损失函数解决了模型如何训练的问题。 这三者的优化是并行的。 （2）鲁棒性和泛化性的关系 对抗样本是一个子问题，是特殊的关系。 （3）鲁棒性和准确性是否矛盾？ 在cv领域，用对抗样本进行数据增强往往会导致鲁棒性上升而准确性下降。而在NLP领域，由于数据多、模型大，它们的表征能力capacity往往更强，进行对抗训练往往是鲁棒性和准确性同时提升的。 （4）普通分类错误的样本和对抗样本有什么区别？ 谢教授说他不会，可以思考下。 或许普遍意义上没有区别，感觉都是没学到足够的特征。乱说的，以后想到了来修改。","categories":[{"name":"AISP","slug":"AISP","permalink":"https://cyccyyycyc.github.io/categories/AISP/"}],"tags":[{"name":"对抗样本","slug":"对抗样本","permalink":"https://cyccyyycyc.github.io/tags/%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC/"}]},{"title":"Hierarchical-Clustering","slug":"Hierarchical-Clustering","date":"2022-10-22T11:10:17.000Z","updated":"2022-10-23T05:29:20.672Z","comments":true,"path":"2022/10/22/Hierarchical-Clustering/","link":"","permalink":"https://cyccyyycyc.github.io/2022/10/22/Hierarchical-Clustering/","excerpt":"","text":"[TOC] 层次聚类 Hierarchical-Clustering 场景 随着网络技术的发展，我们迎来了信息爆炸的时代。我们都知道现代大数据有4个特点： 体量大 Volume 高速化 Velocity 多样化 Variety 低价值密度 Value 未经处理的数据信息之间的联系往往较低，体量大而价值密度低。为了更好地挖掘数据价值，一个思路是找到数据之间的相似点进行度量和聚类，将数据点进行聚类，获得关联以更好地利用数据。网络世界中的推荐算法就是数据应用的一个典型例子。如淘宝、京东、拼多多等购物平台的商品推荐页面，谷歌、百度等搜索引擎的推荐回答，网易云音乐的日推歌曲…高效的推荐算法可以帮助我们快速的从体量庞大的信息流中定位到我们需要的有价值的数据，一定程度上便利了我们的生活。 推荐算法如何能实现推荐我们感兴趣的内容呢？我们往往会发现这样一个事实：品味相似的人会对相似的事物感兴趣。由此衍生出的一个思路是从相似的人出发：如找到兴趣爱好相同的两个人A和B，便可以将A感兴趣的内容推荐给B，由此推广到整个社区类群。在实际应用中，有协同过滤算法基于用户历史数据对用户进行群组划分并在此基础上推荐相似的物品，挖掘用户潜在兴趣。 在协同过滤中实现聚类有较多方法，本实验选择自底向上的层次聚类进行复现。 原理 先明确我们要实现什么：我们有一些离散的无关联的数据点，想要衡量它们之间的相似度，并以此为准则进行聚类。 那么这就要解决2个问题： 相似度如何定义？ 如何评估聚类的效果？ 首先，关于相似度定义的问题，需要定义一个函数来进行样本距离的衡量。如： Single-Linkage最短距离法：取两个类中距离最近的两个样本的距离作为两个集合的距离。 Complete-Linkage最长距离法：取两个集合中距离最远的两个点的距离作为两个集合的距离。 Average-linkage中间距离法：取两两距离的平均值作为两个集合之间的距离。 类平均法：取两两距离的中值作为两个集合之间的距离。 四种方法各有特点： 最短距离法相对限制较少，最终会得到一个相对松散的社群。 最长距离法相对限制较大。一个问题是：有可能两个类群已经很接近了，但由于单个样本的干扰便没有合并。 最短距离和最长距离法这考虑了某个有特点的数据，而没有考虑类内数据的整体特点，时间复杂度相对较低。 类平均法与取均值相比更能消除个别偏离样本对结果的干扰。 其次，关于聚类效果评估的问题。容易发现，聚类和分类是不同的。对于分类问题，我们已经有了正确的标签，因此分类问题是一个有监督的学习。而聚类本身没有一个“正确”的结果，是一种无监督的学习。因为聚类没有一个确定的答案，目前尚未有一个效果较好的的评测指标评价聚类效果，更多的是靠数据可视化和人工评测效果。 层次聚类有两种思路： 自底向上的凝聚法：凝聚法指的是初始时将每个样本点当做一个类簇，然后依据相似度合并这些初始的类簇，直到达到某种条件或者达到设定的分类数目。 自顶向下的分裂法：初始时将所有的样本归为一个类簇，然后依据相似度进行逐渐的分裂，直到达到某种条件或者达到设定的分类数目。 特点 优点 距离度量函数可以任意定义，较为灵活。 层次聚类结果是一个树状图，包含关系结构清晰，一个结点可以属于多个类。 一次性获得整个聚类树，可以直接根据需要对聚类树进行横向切割获得指定数量的类簇。 缺点 计算复杂度大 贪心算法获得局部最优，不一定是全局最优解。 层次聚类具有不可逆性，一旦聚类结果形成，想要就不能重新合并来优化聚类性能。 对于不同的问题，需要人为选择合适的距离度量函数、终止条件和参数。 实现步骤 移除网络中的所有边，得到有 n 个孤立节点，每个节点作为一个集合。 两两计算相似度 根据选取相似度最小的两个结点进行合并 重复2和3直到满足条件终止，形成树状图 根据实际需求横切树状图，获得聚类的社区结构 代码执行 依赖 12345python==3.8.8numpy==1.23.3scipy==1.7.0scikit-learn==1.1.2matplotlib==3.5.3 代码实现 导入库 12345678# 导入库import numpy as npimport matplotlib.pyplot as pltfrom scipy.cluster import hierarchyfrom sklearn.cluster import AgglomerativeClusteringfrom sklearn import datasetsfrom sklearn import preprocessing%matplotlib inline 导入数据 12345# 导入数据集iris = datasets.load_iris()iris_data = iris.dataprint(iris_data.shape, iris_data.dtype)# output:(150, 4) float64 数据预处理 123456789# 数据集预处理data = np.array(iris_data[:, 1:-1])print(data.shape)# output:(150, 2)# 将数据的每一个特征缩放到给定的范围(0,1)min_max_scaler = preprocessing.MinMaxScaler()data_M = min_max_scaler.fit_transform(data) 层次聚类树状图 1234567plt.figure(figsize=(20, 6))plt.title(&quot;Dendrograms&quot;) # ward：集合间距离等于两类对象之间的最小距离。（即最短距离法single-linkage聚类）# 计算距离的方法，可以是 “euclidean”（即 “l2”，欧氏距离）Z = hierarchy.linkage(data_scaled, method=&#x27;ward&#x27;, metric=&#x27;euclidean&#x27;)p = hierarchy.dendrogram(Z, 0)plt.show() 层次聚类分布图 1234567# ward：集合间距离等于两类对象之间的最小距离。（即最短距离法single-linkage聚类）# 计算距离的方法，可以是 “euclidean”（即 “l2”，欧氏距离）ac = AgglomerativeClustering(n_clusters=6, affinity=&#x27;euclidean&#x27;, linkage=&#x27;ward&#x27;)ac.fit(data_scaled)labels = ac.fit_predict(data_scaled)plt.scatter(data_scaled[:,0], data_scaled[:,1], c=labels)plt.show()","categories":[],"tags":[]},{"title":"The Transfer-based Black-box Attack Method by 韦星星","slug":"The-Transfer-based-Black-box-Attack-Method-by韦星星","date":"2022-10-19T15:57:49.000Z","updated":"2022-10-21T03:50:27.089Z","comments":true,"path":"2022/10/19/The-Transfer-based-Black-box-Attack-Method-by韦星星/","link":"","permalink":"https://cyccyyycyc.github.io/2022/10/19/The-Transfer-based-Black-box-Attack-Method-by%E9%9F%A6%E6%98%9F%E6%98%9F/","excerpt":"","text":"观后感 Source The 4th Lecture 基于Spatial Momentum的迁移性增强方法 FGSM : Fast Gradient Sign Method 白盒场景下，用符号获得梯度方向，在原图增加噪声（对抗扰动）来生成对抗样本，是一种单步迭代攻击。 I-FGSM : Iterative Fast Gradient Sign Method 多步迭代攻击，拟合效果更好了，但是迁移性不太好（可以从overfit角度直观理解） 时序累加角度：时间域变换 MI-FGSM 时序上的梯度累加：当前梯度+过去梯度 NI-FGSM 数据增广角度：空间域变换 DII-FGSM : Diverse Inputs 从数据增强角度，对输入数据有概率p进行随机大小的resize TI-FGSM : Translation invariant - FGSM 从数据增强角度，考虑像素点的领域（高斯）来生成对抗样本。 时空累加角度 R-DIMI-FGSM 考虑梯度在空间上的累加，比较范围更广 图像检测对抗样本的生成 现有方法问题 现有攻击方法常常针对Fast-rcnn，攻击模型中的的分类模块（常常表征高级特征），而有些图像检测模型如yolo模型中无分类模块，则导致迁移性差。 迁移性差，在一个模型训练生成的对抗样本往往无法成功攻击另一个模型。 时间复杂度高 改进 改进描述 一种想法是对抗样本迁移和模型之间的共性相关。要想增强迁移能力，则应该从模型间的共性切入。 传统方法是攻击Fast-rcnn模型中的分类模块，而有些模型中不存在分类模块，则分类模块显然不是模型的共同子架构。 因此，提出基于base network的对抗样本生成，取Fast-rcnn模型中一些普遍应用的架构（如VGG、ResNet一些经典架构…），用attention机制来定位特征层的目标机制，增加feature loss，从中间特征层入手破坏物体特征层的特征（原来是直接攻击模型更后面更高级的分类模块），获得更高的迁移性。 Q1 ：底层特征更共性？ 这时候可能有人会提出一个问题，既然攻击迁移性往往和模型之间的共同点高度相关，那为什么不选取破坏更加具有共性的底层特征来获得更大的迁移性呢？回答是这样对图片的破坏较大，会导致对抗样本和原图的距离较远，选择在中间特征层攻击是对图片质量（和原图的相似度）和迁移性的权衡结果。 进一步解释，神经网络往往是一个放大的过程，在底层添加微小噪声，经过网络不断放大，最终和原图便相去甚远。 Q&amp;A Q1：可以从什么角度切入提高迁移性? 从梯度出发，找到一个更泛化的梯度计算的方法 从模型架构共性出发。现在的模型架构趋于模块化，更容易找到共性，提高迁移性。 （笔者目前个人认为）从模型拟合数据分布的角度出发。不同模型学到的知识不同，有的模型注重纹理有的注重轮廓。 Q2 ：无法被迁移攻击的模型？ 从模型架构共性出发：黑盒场景下，如果一个模型无法被迁移攻击，那么说明本地模型和目标模型相似度极低。这不太符合现实应用。不过脉冲神经网络或许是一个角度。 从模型拟合数据分布角度出发：往往经过对抗训练的模型会具有更高的鲁棒性，相同架构下往往会更难以被对抗攻击，这表明模型拟合出了一个不一样的分布，这个分布含有更多的知识。（有点像“吃一堑长一智”，模型之前见识过了对抗攻击，便学会了如何应对） Q3 ：语义角度的迁移攻击？ 现有方法往往修改图像亮度、锐度、饱和度等属性（对抗属性）来生成对抗样本。可以进行扩展，尝试修改一些视觉友好的语义属性（比如颜色）来生成对抗样本，思考并探索：哪种属性更易于迁移？ Q4 ：如何寻找共性？ 从data的特征空间变换角度，可以寻找不同模型之间的一致性 从降维解构角度，可以实现降低搜索维度，在低维空间中搜索降低时间复杂度，在高维空间中攻击获得好的攻击效果。 Q5 ：迁移性的理论相关？ 目前理论尚待完善。 关于可迁移性的度量，由于迁移并不独立存在，一定是从一个模型到另一个模型，所以目前也无统一度量方法。 Q6 ：可证明的迁移攻击的防御 由于目前迁移攻击的发展空间巨大（效果很差成功率很低），所以没有相关的防御。一般经过对抗训练就能很好地防御了。","categories":[{"name":"AISP","slug":"AISP","permalink":"https://cyccyyycyc.github.io/categories/AISP/"}],"tags":[{"name":"对抗样本","slug":"对抗样本","permalink":"https://cyccyyycyc.github.io/tags/%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC/"}]},{"title":"Deepfake by 吕思伟","slug":"Deepfake-by吕思伟","date":"2022-10-18T13:55:02.000Z","updated":"2022-10-21T03:49:49.871Z","comments":true,"path":"2022/10/18/Deepfake-by吕思伟/","link":"","permalink":"https://cyccyyycyc.github.io/2022/10/18/Deepfake-by%E5%90%95%E6%80%9D%E4%BC%9F/","excerpt":"","text":"观后感 Source The 3td Lecture DEEP FAKE Background 硬件近年来发展迅速，甚至超过了摩尔定律描述的速度。 互联网用户多，数据体量庞大，且传播较快较广泛。 AI发展迅速（其实是被大数据和高效的计算资源推着发展的） Application GAN-based Image 生成的fake_images有如下目标： 质量高，有逼真的特征细节纹理 种类多 DNN-based Speech VC (voice conversion)：可以理解为风格转换，A的内容＋B的风格 TTS (Text to Speech) AE-based Video 理解为逐帧进行替换（风格转换） Decoder 分离identity and message，Encode进行一个重新添加。 问题：耗费较多训练资源，目前还需要比较多的人为调整，而调整操作必然留下痕迹，这也利于检测。 Impact Positive 电影高难度动作、或者一些场景都可以进行生成 游戏、远程教育可以通过生成提高交互性 利于数字匿名化，隐藏个人的identity，可用于个人隐私保护 生成更具多样性的数据集 Negative(main) 制造假象，混淆视听，误导大众做出错误决策 降低公众对媒体的信任感，俗称一颗老鼠屎坏了一锅粥 信息量变大了，含金量并没有提高，信息流变得更为复杂。 Detection 虚假信息其实一直都存在，只是随着AI的发展，虚假信息流增强，更难以分辨且威胁性更大，由此Deep-Fake Detection愈发重要。 下图为吕思伟教授在讲座中给出的DeepFake Detection分类 首先明确DeepFake检测是一个二分类问题。 其次可分为Single-modality 和 Multi-modality。 目前主流是Single-modality --&gt; Frame-based --&gt; Data-driven的检测手段。 Cue可以理解为Feature： Signal cues：不关心内容，只关心数据本身构成。如Post-processing方法，即为检测生成fake_images后贴到视频里的后处理痕迹，鉴定是否为真。 Semantic cues：关心数据内容本身是否符合规律。如人脸各个组成的朝向是否正确，如眨眼频率。（个人感觉听起来可延展性较弱，貌似只能针对特定数据特定分布，而且开源后攻击者就可以注意到这个规律，生成符合特定规律的图像就可以骗过检测模型了） 总体感觉，没有一个普适性的、统一的、可延展的完善的检测方法，较为零碎。 Challenge 可解释性：随着Deep-Fake的负面影响越来越严重，除了需要检测出”鉴定为假“的结果，在实际应用中，往往不能单纯依靠机器判别，还需要给出假的理由。 目前检测方法从不同角度切入，种类很多，但可扩展性不强，缺乏一个统一的检测方法。攻击者可以很容易针对专门检测方法进行调整，绕过检测防御。 很多检测方法误判率较高。实际应用中容易影响用户体验感。 目前的检测手段实际上是一种事后的被动防御。现在很多人都有一致的想法，利用后门去破坏Deep-Fake的生成，进行主动防御。 Future 生成范围逐渐扩展。不再局限于人脸，逐渐生成四肢、全身… 共同生成音效＋视频帧，更加逼真 逐步减少对数据的依赖。比如由单张图片生成动态的视频，由低维构建高维场景。","categories":[{"name":"AISP","slug":"AISP","permalink":"https://cyccyyycyc.github.io/categories/AISP/"}],"tags":[{"name":"DeepFake","slug":"DeepFake","permalink":"https://cyccyyycyc.github.io/tags/DeepFake/"}]},{"title":"深度学习反脆弱技术的攻防和测评By刘祥龙","slug":"深度学习反脆弱技术的攻防和测评By刘祥龙","date":"2022-10-18T11:55:09.000Z","updated":"2022-10-21T03:50:55.386Z","comments":true,"path":"2022/10/18/深度学习反脆弱技术的攻防和测评By刘祥龙/","link":"","permalink":"https://cyccyyycyc.github.io/2022/10/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%8F%8D%E8%84%86%E5%BC%B1%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E9%98%B2%E5%92%8C%E6%B5%8B%E8%AF%84By%E5%88%98%E7%A5%A5%E9%BE%99/","excerpt":"","text":"Source: 论坛网站The 2nd Lecture 引入 安全挑战 非人为刻意引发 网络安全，公共安全（安检、自动驾驶），国防安全（侦察、遥感监测）等 人为刻意构造的全新类型攻击 对抗样本、噪音污染、数据投毒、数据伪造、后门攻击… 对抗样本 特点 一类被恶意设计来攻击AI模型的样本 与真实样本的差异不易感知 可以导致模型进行错误的判断 “脆弱性在深度学习中具有普遍性”（Nature 2019） 本次主要从对抗样本角度出发关注深度学习的脆弱性。 数字世界中的对抗样本 特点 微小扰动，不易觉察 语义不变而欺骗模型 攻击分类 黑盒攻击 白盒攻击 FGSM attack:2014,基于梯度的攻击 攻击假设：白盒，可以获得模型反向传播的梯度符号 特点 1.fast 2.sign C&amp;W attack:2017,基于优化的攻击 攻击假设：白盒，攻击者需要获得模型数据 数学理解 D：distance C：classification f: 目标函数。当且仅当 f(x+δ)≤0时, C(x+δ)=t 函数连续：因为要进行优化，所以目标函数需要是光滑连续有梯度的。 slow：因为涉及多步优化计算w，所以速度相对较慢。 PBBA:2017,基于迁移的攻击 攻击假设：黑盒 对代理模型的攻击迁移到其它模型 AdvGAN:2018,基于模型的攻击 攻击假设：白盒生成，需要获得受害者模型数据来计算adv-L 其它任务 Video Analysis 视频逐帧攻击 Speech Recognition Natural Language Processing 自然语言处理领域的对抗样本： 对于人类，语序不影响阅读，而文本字母顺序的调换会让模型输出错误的结果。 Reinforcement Learning 强化学习领域对抗样本的运用实际上是对策略的攻击 一种理解是模型本身不够完善，没有学习到如何应对这个策略 防御 物理世界中的对抗样本 物理世界对抗样本：改造物理实体以进行攻击 受限于：感知器质量、光照强度、远近距离… 与数字世界对抗样本相比，物理世界对抗样本具有黑盒特性，更复杂，危险性更大 根据数字世界和物理世界的差异，给出对抗样本泛化定义： 1.对于人类，视觉上具备友好性 For human, it disguises as a normal example. 2.对于模型具有攻击性，可以欺骗模型 For models, it misleads the model predictions 反脆弱技术体系 脆弱性原理 从关键决策路径动态地来看： 关键攻击路径刻画了从输入端到决策输出端错误输出的传播路径，这是对模型泛化应用影响最大的路径。 表明神经网络中存在脆弱单元，脆弱路径。 从注意力机制来看： 模式识别存在一定偏好，可能对特定的特征（如纹理）有一定偏好（理解为容易激活） 脆弱性检测 深度学习网络的对抗鲁棒性和自然噪音鲁棒性往往呈现正相关。提高对抗鲁棒性利于整体鲁棒性的优化，这需要完备数据集的支撑。 问题：人工智能要想获得广泛使用，成为基础设施，就要有可靠性的保证。 挑战：建立完善的评估指标、技术规范和工具集，去测试其模型的可靠性。 反脆弱加固 数据端 过滤有害数据，但没有优化模型本身的反脆弱能力。 1.污染检测 对于数据进行domain迁移，数据增强，提高模型泛化能力 2.污染抑制 增加防御补丁 3.污染抑制 利用W-Distance来进行数据增强，提高模型泛化能力 模型端：提高鲁棒性 1.训练加固 模型单元增强：在中间层注入多样化的对抗噪音，提高鲁棒性，使其学习到更多的语义信息 2.结构优化： 抑制脆弱路径：剪枝，压缩，稀疏化，量化，一定程度上可以抑制噪音 中心加权归一化BN进行神经网络模型数据分布整合，提高模型分布的稳定性和收敛性，改善了曲率 Q&amp;A 如何平衡模型的精确性和鲁棒性？ 模型的精确性和鲁棒性使多因素共同作用下的结果，应该全面分析不同因素作用，综合考量设计优化目标 一种设想：大网络下的特定子网络结构具有鲁棒性","categories":[{"name":"AISP","slug":"AISP","permalink":"https://cyccyyycyc.github.io/categories/AISP/"}],"tags":[{"name":"对抗样本","slug":"对抗样本","permalink":"https://cyccyyycyc.github.io/tags/%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC/"}]},{"title":"数字图像处理","slug":"数字图像处理","date":"2022-10-18T11:32:23.000Z","updated":"2022-10-21T03:50:48.707Z","comments":true,"path":"2022/10/18/数字图像处理/","link":"","permalink":"https://cyccyyycyc.github.io/2022/10/18/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/","excerpt":"","text":"图像基础 图片表示 二值图 只有2种取值 灰度图 unit8 8位灰度图（0~255） 二维矩阵（一个通道） 彩色图 三维矩阵（RGB三个通道） 真彩色 通道的分离和合并 12345img_bgr = cv.imread(img_path)# 通道分离b, g, r = cv.split(img_bgr)# 通道合并img_rgb = cv.merge([r, g, b]) 彩色图转换成灰度图 1234567# 三通道按权值加权 0.299 0.587 0.114gray1 = 0.299 * r + 0.587 *g + 0.114 *b# dtype = uint8gray2 = np.uint8(gray1)gray3 = gray1.astype(np.uint8)gray4 = cv.cvtColor(img_bgr, cv.COLOR_BGR2GRAY) 图像二值化 123456thresh = 125gray4[gray4 &gt; thresh] = 255gray4[gray4 &lt;= thresh] = 0# gray4 已经被二值化ignore, img_bin = cv.threshold(gray_uint8_img, th1, th2, cv.THRESH_BINARY) 图像运算 图像相加 混合图像、添加噪声 12345# dtype = float64img_add1 = cv.add(img1*0.5, img2*0.5)# dtype = uint8img_add2 = cv.addWeighted(img1, alpha, img2, beta, gamma) 图像相减 消除背景、差影法（比较差异，运动跟踪） 1img_sub = cv.subtract(img1, img2) 图像相乘 掩膜mask 1img = cv.multiply(img1, img2) 图像相除 校正设备、比较差异 1img = cv.divide(img1, img2) 图像变换 线性变换 s=b+krs=b+kr s=b+kr 1img = cv.convertScaleAbs(img, alpha=1, beta=0) 非线性变换 s=a+ln(r+1)blncs=a+\\frac{ln(r+1)}{blnc} s=a+blncln(r+1)​ Gamma变换 s=crys=cr^y s=cry y越大图像越亮 12img = img / 255img = np.power(img, y) * 255 图像处理 裁剪 12345# numpyimg = cv.imread(img_path)# h * w * c# y * x *cimg = img[20:100, 100:200, :] 放缩 123# OpenCv# (x, y)=(w, h)=(500,400)img = cv.resize(img, (500, 400)) 平移 仿射变换 123# 坐标的映射矩阵MM = np.array([...], dtype=np.float32)cv.warpAffine(img, M, dsize) 错切变换 12M = np.array([...], dtype=np.float32)img = cv.warpAffine(img, M, dsize) 镜像变换 123456789101112# 矩阵M = np.array([...], dtype=np.float32)img = cv.warpAffine(img, M, dsize)# 垂直镜像cv.flip(img, 0)# 水平镜像cv.flip(img, 1)# 同时进行cv.flit(img, -1) 旋转变换 123456789101112# 旋转矩阵M = np.array([...], dtype=np.float32)img = cv.warpAffine(img, M, dsize)# M = cv.getRotationMatrix2D(center, angle, scale)h, w, c = img.shape# center = (x, y)M = cv.getRotationMatrix2D((w//2, h//2), 45)img = cv.warpAffine(img, M, dsize)# 顺时针逆时针旋转90°img_rotate = cv.rotate(img, cv.ROTATE_90_CLOCKWISE) 透视变换 12M = cv.getPerspectiveTransform(src, dst)img = cv.warpPerspective(img, M, dsize) 小总结 像素值没变，像素位置变了。 所以实际上计算了一个坐标变换的矩阵M。 最近邻插值 逆向思维：小图插值变大图 —&gt; 大图变小图 1img1 = cv.resize(img, dsize, interpolation=cv.INTER_NEAREST) 双线性插值 考虑邻近的像素点，按照权值计算。 1img1 = cv.resize(img, dsize, interpolation=cv.INTER_LINEAR_EXACT) 图像模糊 卷积 1img = cv.filter2D(img, -1, kernel) 均值模糊 123cv.blur(img, (5,5))cv.boxFilter(img, -1, (5,5)) 中值滤波 1cv.medianBlur(img, 3) # 奇数 高斯模糊 1234# sigma 方差# 方差小则copy原图# 方差大则和均值滤波差不多cv.GaussianBlur(img, (5,5), sigmaX) 双边滤波 一般模糊会丢失边缘信息，而双边滤波可以保留边缘高频信息，平滑颜色相近的地方。 需要一直更新卷积核的值： 距离越远，加权值越小 颜色差异越大，加权值越小 缺点：对高频噪声无滤波效果 1cv.bilateralFilter(img, -1, sigmaColor=50, sigmaSpace=3) 图像边缘 …","categories":[{"name":"cv","slug":"cv","permalink":"https://cyccyyycyc.github.io/categories/cv/"}],"tags":[]}],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://cyccyyycyc.github.io/categories/Algorithm/"},{"name":"AISP","slug":"AISP","permalink":"https://cyccyyycyc.github.io/categories/AISP/"},{"name":"cv","slug":"cv","permalink":"https://cyccyyycyc.github.io/categories/cv/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cyccyyycyc.github.io/tags/leetcode/"},{"name":"对抗鲁棒性","slug":"对抗鲁棒性","permalink":"https://cyccyyycyc.github.io/tags/%E5%AF%B9%E6%8A%97%E9%B2%81%E6%A3%92%E6%80%A7/"},{"name":"对抗样本","slug":"对抗样本","permalink":"https://cyccyyycyc.github.io/tags/%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC/"},{"name":"DeepFake","slug":"DeepFake","permalink":"https://cyccyyycyc.github.io/tags/DeepFake/"}]}